<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Play</title>
  <icon>https://www.gravatar.com/avatar/37f5042e32043c8bcdfe0a7b75ed5267</icon>
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-08T15:04:12.265Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>南懿烨曦</name>
    <email>869083577@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一篇博客解决常见的排序</title>
    <link href="http://example.com/2022/09/08/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E8%A7%A3%E5%86%B3%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/09/08/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E8%A7%A3%E5%86%B3%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F/</id>
    <published>2022-09-08T14:20:47.000Z</published>
    <updated>2022-09-08T15:04:12.265Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><img src="https://img-blog.csdnimg.cn/493e3f19c18f4940a19041cc9ff75f56.gif#pic_center" alt="在这里插入图片描述"></p><p>遍历n次数组，如果当前数比后一个数大则将当前<br>数与后一个数交换位置，每遍历一次可排好一个数<br>的位置，直到n次，时间复杂度为O（N2），排序满足稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] ints)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; ints.length-i; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[j];</span><br><span class="line">                <span class="keyword">if</span> (ints[j]&lt;ints[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    ints[j] = ints[j-<span class="number">1</span>];</span><br><span class="line">                    ints[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BubbleSort</span>().bubbleSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img src="https://img-blog.csdnimg.cn/a60a023b7dee45209a255cbb569f5ffa.gif#pic_center" alt="在这里插入图片描述"></p><p>遍历数组，每一次遍历都会从当前位置之后寻找最小的数，并记录最小数的位置，然后将当前值和最小值交换，完整遍历后可以得到一个顺序列表，时间复杂度为O（N2），排序满足稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] ints)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> ints[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> first;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; ints.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j]&lt;tmp)&#123;</span><br><span class="line">                    tmp = ints[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[i] = ints[index];</span><br><span class="line">            ints[index] = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SelectionSort</span>().selectionSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="https://img-blog.csdnimg.cn/4f3f096c237b4d85b50e0e39fcc28b03.gif#pic_center" alt="在这里插入图片描述"></p><p>每次排序前先选择一个基准数，然后把比基准数小的放左边，比基准书大的放右边，具体方法是用两个指针，一个从左到右，一个从右到左，左指针找到比基准数大的数时，将左指针的数和右指针的数交换，然后右指针开始向左找比基准书小的数，找到后和左指针的数交换，直到两个指针相遇，此时数组被分成两个区域，再对这两个区域进行快排递归，直到所有数都排好为止<br>时间复杂度为O(nlogn),在最坏的情况下为O(N2),且不能保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] ints,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">baseNum</span> <span class="operator">=</span> ints[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">while</span> (ints[r]&gt;=baseNum&amp;&amp;l&lt;r)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    ints[l] = ints[r];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (ints[l]&lt;=baseNum&amp;&amp;l&lt;r)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    ints[r] = ints[l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[l] = baseNum;</span><br><span class="line">            quickSort(ints,left, r-<span class="number">1</span>);</span><br><span class="line">            quickSort(ints,l+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">QuickSort</span>().quickSort(ints,<span class="number">0</span>,ints.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://img-blog.csdnimg.cn/0417393bd8fc45eb80d6938896c9cf4d.gif#pic_center" alt="在这里插入图片描述"></p><p>分治的思想，先将整个数组一分为二，再二分为四……直到分成一个部分只有一个元素为止，这是分的思想。将分出来的部分合并为一个有序的部分，两个已经排好序的部分合并就比较容易了，每一次只需要比较头元素的大小，然后选择小的那个加入到中间数组里即可，用递归的方法可以很好的实现这个思想<br>时间复杂度稳定为O(nlogn),并且能保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[ints.length];</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(ints,left,mid);</span><br><span class="line">            sort(ints,mid+<span class="number">1</span>,right);</span><br><span class="line">            merge(ints,left,mid,right,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] tmp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=mid||r&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;mid)&#123;</span><br><span class="line">                tmp[index++] = ints[r++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;right)&#123;</span><br><span class="line">                tmp[index++] = ints[l++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[l]&lt;ints[r])&#123;</span><br><span class="line">                tmp[index++] = ints[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[index++] = ints[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            ints[i] = tmp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MergeSort</span>().sort(ints,<span class="number">0</span>,ints.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="https://img-blog.csdnimg.cn/2a8e4c9efa1847c4a43a6448b1371bc7.gif#pic_center" alt="在这里插入图片描述"></p><p>将数据重新排列成一个最小堆，即每个结点的父节点都小于其子结点，这样顶部的元素一定是当前堆的最小值，将顶部元素取出并将叶子结点放置到顶部元素，这样操作后可能会破坏最小堆的结构，所以此时需要重新生成最小堆，这样又可以得出这个堆的最小值，这样重复操作，直到所有数都被取出<br>时间复杂度稳定为O(nlogn),并且保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] ints)</span>&#123;</span><br><span class="line">        <span class="comment">//形成最小堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ints.length-<span class="number">1</span>; i &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="comment">//只有一个子结点且为左子结点</span></span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> i/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ints[father]&gt;ints[i])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[father];</span><br><span class="line">                    ints[father] = ints[i];</span><br><span class="line">                    ints[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> (i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> ints[i]&lt;ints[i-<span class="number">1</span>]?ints[i]:ints[i-<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> ints[i]&lt;ints[i-<span class="number">1</span>]?i:i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (small&lt;ints[father])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[father];</span><br><span class="line">                    ints[father] = ints[smallIndex];</span><br><span class="line">                    ints[smallIndex] = tmp;</span><br><span class="line">                    arrange(ints,smallIndex, ints.length);</span><br><span class="line">                &#125;</span><br><span class="line">                i-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> ints.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[lastIndex];</span><br><span class="line">            ints[lastIndex--] = ints[<span class="number">0</span>];</span><br><span class="line">            ints[<span class="number">0</span>] = tmp;</span><br><span class="line">            arrange(ints,<span class="number">0</span>,lastIndex+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">arrange</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> index,<span class="type">int</span> intsLength)</span>&#123;</span><br><span class="line">        <span class="type">int</span> leftChildIndex;</span><br><span class="line">        <span class="type">int</span> rightChildIndex;</span><br><span class="line">        <span class="comment">//判断有无左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (index*<span class="number">2</span>+<span class="number">1</span>&lt;intsLength)&#123;</span><br><span class="line">            leftChildIndex = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//有两个结点的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((index+<span class="number">1</span>)*<span class="number">2</span>&lt;intsLength)&#123;</span><br><span class="line">                rightChildIndex = (index+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> ints[leftChildIndex]&lt;ints[rightChildIndex]?ints[leftChildIndex]:ints[rightChildIndex];</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> ints[leftChildIndex]&lt;ints[rightChildIndex]?leftChildIndex:rightChildIndex;</span><br><span class="line">                <span class="keyword">if</span> (small&lt;ints[index])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[index];</span><br><span class="line">                    ints[index] = ints[smallIndex];</span><br><span class="line">                    ints[smallIndex] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                arrange(ints,smallIndex,intsLength);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有一个子节点的情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[leftChildIndex]&lt;ints[index])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[index];</span><br><span class="line">                    ints[index] = ints[leftChildIndex];</span><br><span class="line">                    ints[leftChildIndex] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HeapSort</span>().heapSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排</summary>
      
    
    
    
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最长无重复子序列</title>
    <link href="http://example.com/2022/03/10/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/03/10/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-03-10T13:52:18.000Z</published>
    <updated>2022-03-10T14:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h1><pre><code>这是我的第一个算法题记录，以后都会以这种形式记录下来</code></pre><p>刷力扣其实是我很早之前就想做的了，大一的时候有段时间有这样的兴致，但也只是刷了几道题就没坚持了，以前也有遇到过那种很有趣的题，可惜没有记录，现在回去再做一次又感觉不值了。所以现在我尽量把那些有意思的题记录一下，也算是当做自己的一种积累吧。</p><p>这次突然开始刷力扣也算因为，哈哈哈，马上要笔试了，临时抱佛脚而已，做这道题也花了我一个小时，刚开始是思路有了，奈何没有正确的方法去实现，真正笔试的时候时间早过了。。。</p><hr><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>无重复字符的最长子串</strong><br>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 5 * 104</li><li>s 由英文字母、数字、符号和空格组成</li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始想到的是暴力解，但是肯定是不给过的，果断放弃<br>在给字符编号的时候发现，可以将相同字符的指标记录下来，然后按照1，2，3，4….这样的顺序来取字符，如果遇到相同的字符就将其替换掉，并去除之前的数</p><p>比如：abcabcbb<br>a的指标有</p><ul><li>a:0,3</li><li>b:1,4,6,7</li><li>c:2,5</li></ul><p>接着开始从最开始编号</p><table><thead><tr><th align="left">0</th><th align="center">1</th><th align="right">2</th></tr></thead><tbody><tr><td align="left">a</td><td align="center">b</td><td align="right">c</td></tr></tbody></table><p>编到3的时候发现重复,此时去除第一组键值对接着往下排以此类推，直到最后一个元素</p><table><thead><tr><th align="left"><del>0</del></th><th align="center">1</th><th align="right">2</th><th align="right">3</th></tr></thead><tbody><tr><td align="left"><del>a</del></td><td align="center">b</td><td align="right">c</td><td align="right">a</td></tr></tbody></table><table><thead><tr><th align="left"><del>0</del></th><th align="center"><del>1</del></th><th align="right">2</th><th align="right">3</th><th align="right">4</th></tr></thead><tbody><tr><td align="left"><del>a</del></td><td align="center"><del>b</del></td><td align="right">c</td><td align="right">a</td><td align="right">b</td></tr><tr><td align="left">……</td><td align="center"></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table><p>太巧了，这正是一个可排序的哈希表可以解决的问题，但不幸的是，Java自带的LinkedHashMap没有删除首元素这个方法，寄！<br>或许它是有的但是我不会用，更寄！<br>所以我就自己写了一个类似linkedhashmap但是带删除首元素的方法</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> ch,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.ch = ch;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Node&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Node&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(ch,i);</span><br><span class="line">            <span class="comment">//如果该字符出现过</span></span><br><span class="line">            <span class="keyword">if</span> (hashMap.get(ch) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (linkedList.size() &gt; max) &#123;</span><br><span class="line">                    max = linkedList.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//删掉重复值及其之前的值</span></span><br><span class="line">                <span class="keyword">while</span> (linkedList.getFirst().index&lt;hashMap.get(ch).index)&#123;</span><br><span class="line">                    hashMap.remove(linkedList.removeFirst().ch);</span><br><span class="line">                &#125;</span><br><span class="line">                hashMap.remove(linkedList.removeFirst().ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将这个元素添加至链表和哈希表中</span></span><br><span class="line">            linkedList.addLast(node);</span><br><span class="line">            hashMap.put(ch,node);</span><br><span class="line">            <span class="keyword">if</span> (linkedList.size()&gt;max)&#123;</span><br><span class="line">                max = linkedList.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>做是做出来了，但是结果不太行，用时只超过了30%，之后再看看优化吧，但估计是不会再更新了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pre&quot;&gt;&lt;a href=&quot;#pre&quot; class=&quot;headerlink&quot; title=&quot;pre&quot;&gt;&lt;/a&gt;pre&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;这是我的第一个算法题记录，以后都会以这种形式记录下来
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刷力扣其实是我很早之前就想做</summary>
      
    
    
    
    
    <category term="算法题" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>知识梳理</title>
    <link href="http://example.com/2022/03/10/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>http://example.com/2022/03/10/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</id>
    <published>2022-03-10T08:50:22.000Z</published>
    <updated>2022-09-08T15:04:31.008Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h1><p>这次知识梳理是为了应对面试的，但是我想的话这之后也有很大的用处，可以检测一下自己的知识面，所以应该会经常更新，我说的是应该。。。</p><p>可能内容的排版会有出入，等之后内容很多了我再调整</p><hr><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>数组查询时比较快，插入和删除比较慢<br>链表查询时比较慢，插入删除比较快<br> <strong>原因:</strong><br>  数组的存储空间是连在一起的方便查询，删除或插入很可能会影响操作点之后的所有数<br>  链表的存储空间是分散的，查询的时候必须从第一个开始，一个一个往下查，所以很慢，删除和插入只用找到那个点位进行操作就ok，不会影响点位之后的数</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>遍历n次数组，如果当前数比后一个数大则将当前<br>数与后一个数交换位置，每遍历一次可排好一个数<br>的位置，直到n次，时间复杂度为O（N2），排序满足稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] ints)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; ints.length-i; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[j];</span><br><span class="line">                <span class="keyword">if</span> (ints[j]&lt;ints[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    ints[j] = ints[j-<span class="number">1</span>];</span><br><span class="line">                    ints[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BubbleSort</span>().bubbleSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>遍历数组，每一次遍历都会从当前位置之后寻找最小的数，并记录最小数的位置，然后将当前值和最小值交换，完整遍历后可以得到一个顺序列表，时间复杂度为O（N2），排序满足稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] ints)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> ints[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> first;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; ints.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j]&lt;tmp)&#123;</span><br><span class="line">                    tmp = ints[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[i] = ints[index];</span><br><span class="line">            ints[index] = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SelectionSort</span>().selectionSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>每次排序前先选择一个基准数，然后把比基准数小的放左边，比基准书大的放右边，具体方法是用两个指针，一个从左到右，一个从右到左，左指针找到比基准数大的数时，将左指针的数和右指针的数交换，然后右指针开始向左找比基准书小的数，找到后和左指针的数交换，直到两个指针相遇，此时数组被分成两个区域，再对这两个区域进行快排递归，直到所有数都排好为止<br>时间复杂度为O(nlogn),在最坏的情况下为O(N2),且不能保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] ints,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">baseNum</span> <span class="operator">=</span> ints[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">while</span> (ints[r]&gt;=baseNum&amp;&amp;l&lt;r)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    ints[l] = ints[r];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (ints[l]&lt;=baseNum&amp;&amp;l&lt;r)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    ints[r] = ints[l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[l] = baseNum;</span><br><span class="line">            quickSort(ints,left, r-<span class="number">1</span>);</span><br><span class="line">            quickSort(ints,l+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">QuickSort</span>().quickSort(ints,<span class="number">0</span>,ints.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治的思想，先将整个数组一分为二，再二分为四……直到分成一个部分只有一个元素为止，这是分的思想。将分出来的部分合并为一个有序的部分，两个已经排好序的部分合并就比较容易了，每一次只需要比较头元素的大小，然后选择小的那个加入到中间数组里即可，用递归的方法可以很好的实现这个思想<br>时间复杂度稳定为O(nlogn),并且能保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[ints.length];</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(ints,left,mid);</span><br><span class="line">            sort(ints,mid+<span class="number">1</span>,right);</span><br><span class="line">            merge(ints,left,mid,right,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] tmp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=mid||r&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;mid)&#123;</span><br><span class="line">                tmp[index++] = ints[r++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;right)&#123;</span><br><span class="line">                tmp[index++] = ints[l++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[l]&lt;ints[r])&#123;</span><br><span class="line">                tmp[index++] = ints[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[index++] = ints[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            ints[i] = tmp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MergeSort</span>().sort(ints,<span class="number">0</span>,ints.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将数据重新排列成一个最小堆，即每个结点的父节点都小于其子结点，这样顶部的元素一定是当前堆的最小值，将顶部元素取出并将叶子结点放置到顶部元素，这样操作后可能会破坏最小堆的结构，所以此时需要重新生成最小堆，这样又可以得出这个堆的最小值，这样重复操作，直到所有数都被取出<br>时间复杂度稳定为O(nlogn),并且保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] ints)</span>&#123;</span><br><span class="line">        <span class="comment">//形成最小堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ints.length-<span class="number">1</span>; i &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="comment">//只有一个子结点且为左子结点</span></span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> i/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ints[father]&gt;ints[i])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[father];</span><br><span class="line">                    ints[father] = ints[i];</span><br><span class="line">                    ints[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> (i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> ints[i]&lt;ints[i-<span class="number">1</span>]?ints[i]:ints[i-<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> ints[i]&lt;ints[i-<span class="number">1</span>]?i:i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (small&lt;ints[father])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[father];</span><br><span class="line">                    ints[father] = ints[smallIndex];</span><br><span class="line">                    ints[smallIndex] = tmp;</span><br><span class="line">                    arrange(ints,smallIndex, ints.length);</span><br><span class="line">                &#125;</span><br><span class="line">                i-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> ints.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[lastIndex];</span><br><span class="line">            ints[lastIndex--] = ints[<span class="number">0</span>];</span><br><span class="line">            ints[<span class="number">0</span>] = tmp;</span><br><span class="line">            arrange(ints,<span class="number">0</span>,lastIndex+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">arrange</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> index,<span class="type">int</span> intsLength)</span>&#123;</span><br><span class="line">        <span class="type">int</span> leftChildIndex;</span><br><span class="line">        <span class="type">int</span> rightChildIndex;</span><br><span class="line">        <span class="comment">//判断有无左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (index*<span class="number">2</span>+<span class="number">1</span>&lt;intsLength)&#123;</span><br><span class="line">            leftChildIndex = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//有两个结点的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((index+<span class="number">1</span>)*<span class="number">2</span>&lt;intsLength)&#123;</span><br><span class="line">                rightChildIndex = (index+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> ints[leftChildIndex]&lt;ints[rightChildIndex]?ints[leftChildIndex]:ints[rightChildIndex];</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> ints[leftChildIndex]&lt;ints[rightChildIndex]?leftChildIndex:rightChildIndex;</span><br><span class="line">                <span class="keyword">if</span> (small&lt;ints[index])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[index];</span><br><span class="line">                    ints[index] = ints[smallIndex];</span><br><span class="line">                    ints[smallIndex] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                arrange(ints,smallIndex,intsLength);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有一个子节点的情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[leftChildIndex]&lt;ints[index])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[index];</span><br><span class="line">                    ints[index] = ints[leftChildIndex];</span><br><span class="line">                    ints[leftChildIndex] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HeapSort</span>().heapSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="???"></a>???</h3><p>还有其他排序后续加入</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;pre&quot;&gt;&lt;a href=&quot;#pre&quot; class=&quot;headerlink&quot; title=&quot;pre&quot;&gt;&lt;/a&gt;pre&lt;/h1&gt;&lt;p&gt;这次知识梳理是为了应对面试的，但是我想的话这之后也有很大的用处，可以检测一下自己的知识面，所以应该会经常更</summary>
      
    
    
    
    
    <category term="整理" scheme="http://example.com/tags/%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>终于开始了我的个人博客</title>
    <link href="http://example.com/2022/03/10/%E7%BB%88%E4%BA%8E%E5%BC%80%E5%A7%8B%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2022/03/10/%E7%BB%88%E4%BA%8E%E5%BC%80%E5%A7%8B%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-03-10T08:05:01.000Z</published>
    <updated>2022-03-10T13:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我为什么要做个人网站"><a href="#关于我为什么要做个人网站" class="headerlink" title="关于我为什么要做个人网站"></a>关于我为什么要做个人网站</h2><p>之前是一直在csdn上面进行博客记录，社区型的，大家都一样，<strong>没有个性</strong>的那种，在年级的大佬群里面看到各个大佬都有自己的个人网站，而且看起来<strong>非常养眼</strong>，多少有点羡慕。说实话，在csdn上面都没有记录自己学习经历的欲望。在蓝杰的时候老师总是让我们写博客，我一直觉得这是一种作业，多少感觉有点浪费时间。直到现在，我开始准备找实习，准备写简历，准备回顾之前的知识的时候，<strong>哦豁！之前学的东西好多都模糊了，很多都没有记录，这时我才感觉到博客记录的重要性，寄！</strong> 不过还好现在再开始应该还来得及，毕竟现在才大二。</p><hr><h2 id="将来的打算"><a href="#将来的打算" class="headerlink" title="将来的打算"></a>将来的打算</h2><p>目前是打算将技术性的东西或者一些学习上的感想记录在个人网站上，如果有项目的话再将项目传到github上，然后在网站上附上链接，这样子</p><hr><h2 id="网站完善中"><a href="#网站完善中" class="headerlink" title="网站完善中"></a>网站完善中</h2><p>今天就简单把框架搭建了一下，具体的细节打算之后有时间再弄，现在是很多东西都没有加上去，只能先将就用着了，反正现在也就我一个人看，13号字节笔试，14号阿里笔试。。。实在是没有时间耗了，学校还有课程，花旗杯有个项目，微信小程序+springboot还要学<br>大概就先这样吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我为什么要做个人网站&quot;&gt;&lt;a href=&quot;#关于我为什么要做个人网站&quot; class=&quot;headerlink&quot; title=&quot;关于我为什么要做个人网站&quot;&gt;&lt;/a&gt;关于我为什么要做个人网站&lt;/h2&gt;&lt;p&gt;之前是一直在csdn上面进行博客记录，社区型的，大家都一样，</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
