<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Play</title>
  <icon>https://www.gravatar.com/avatar/37f5042e32043c8bcdfe0a7b75ed5267</icon>
  <subtitle>Codes&#39; Playground</subtitle>
  <link href="https://kallenblue.github.io/atom.xml" rel="self"/>
  
  <link href="https://kallenblue.github.io/"/>
  <updated>2023-04-03T11:04:36.007Z</updated>
  <id>https://kallenblue.github.io/</id>
  
  <author>
    <name>南懿烨曦</name>
    <email>869083577@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自问自答</title>
    <link href="https://kallenblue.github.io/2023/03/28/%E9%9D%A2%E8%AF%95/%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/"/>
    <id>https://kallenblue.github.io/2023/03/28/%E9%9D%A2%E8%AF%95/%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/</id>
    <published>2023-03-28T13:43:49.000Z</published>
    <updated>2023-04-03T11:04:36.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>美团面试过后进行的学习方式的调整，每个知识点看完之后还得用自己的语言将其串通才行</p></blockquote><p>我的回答隐藏起来，方便自我检测</p><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"></div></details><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>面试官您好，非常高兴能够参加这次面试。我是来自湖南大学软件工程专业的兰凯伦。自大一开始接触Java以来，我积累了丰富的编程经验，并熟练掌握了Java基础、Java并发、集合等知识。同时，我在学校系统学习了数据结构与算法、计算机原理、计算机网络、操作系统、数据库系统等课程，并对MySQL和Redis数据库有一定的熟悉程度。</p><p>在大三的时候，我自主学习了Spring、MyBatis等框架，并利用这些框架做了一些项目，例如我简历中提到的健康码系统和点餐小程序。在健康码项目中，我负责后端的开发和小程序界面的编写。而点餐小程序是我自己的一个练手项目。此外，在个人奖项方面，我曾获得学校的综合奖学金二等奖、参加华为软件挑战赛获得三等奖和参加物联网大赛获得二等奖。</p><p>在生活中，我乐观开朗、积极向上，并具备较强的学习能力。我善于沟通交流，能够快速地融入新的环境。我非常期待有机会能够加入贵公司，与您共事！这就是我的自我介绍，谢谢！</p></div></details><h1 id="介绍一下你的项目"><a href="#介绍一下你的项目" class="headerlink" title="介绍一下你的项目"></a>介绍一下你的项目</h1><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>健康码项目是我们学校的一个课程项目，开发人员一共有6人，项目主要有普通用户模块，核酸检测人员模块和后台管理模块，我主要负责普通用户模块和核酸检测人员模块，既做前端也做后端，前端使用微信小程序编写，后端使用Spring框架，并使用SpringBoot整合SpringMVC和MybatisPlus等模块进行开发。数据库使用的是MySQL，并使用了Redis作为数据缓存提高访问效率。</p><p>我们做这个项目主要是为了提高自己的编程能力，积累团队协作的经验。在这个项目中我体会到了团队协作中代码规范和接口规范的重要性，在开发一个功能之前要提前商议好接口的返回信息和格式，为了达到类型统一，我们对所有的返回结果都封装为一个Result类，这个类有三个属性，分别是状态码code用于记录请求状态、信息msg用于信息提示、数据data用于存储返回数据。我们还对一些常见的异常进行了异常处理，拦截异常并处理，最后还是返回一个Result对象。</p><p>以上就是我对健康码项目的介绍</p></div></details><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="MySQL的基础结构了解吗"><a href="#MySQL的基础结构了解吗" class="headerlink" title="MySQL的基础结构了解吗"></a>MySQL的基础结构了解吗</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>MySQL主要由Server层和存储引擎层构成<br>Server层主要包括连接器、查询缓存、分析器、优化器、执行器等</p></div></details><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引的数据结构了解吗"><a href="#索引的数据结构了解吗" class="headerlink" title="索引的数据结构了解吗"></a>索引的数据结构了解吗</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>InnoDB作为MySQL默认的索引引擎，其索引的数据结构为B+树，B+树是B树的一种变体，B树又叫多路平衡树，即一个结点有多个子节点。B+树只在叶子结点存储数据，并且叶子结点由双向链表相互连接。B树的任何结点都可以存储数据，且没有链表连接</p></div></details><h4 id="为什么要使用B-树作为索引数据结构，而不使用B树，哈希表"><a href="#为什么要使用B-树作为索引数据结构，而不使用B树，哈希表" class="headerlink" title="为什么要使用B+树作为索引数据结构，而不使用B树，哈希表"></a>为什么要使用B+树作为索引数据结构，而不使用B树，哈希表</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>相对于B树来说，B+树的数据都存储在叶子结点上，其他结点用来存储键值，同样进行一次磁盘IO，B+树能够查询到更多的数据；B+树的叶子结点按键值顺序进行相互连接，可以很好的支持范围查询和高效的顺序查询，但B树不支持</p><p>相对于哈希表来说，B+树支持范围查询和高效的顺序查询，哈希表并不支持；并且哈希表的空间利用率较低，因为哈希表为了解决哈希冲突的问题，可能会需要更多的空间来存储数据。</p></div></details><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>事务是指一系列逻辑操作要么不执行，要么全部执行。对应于MySQL中则是一些列SQL语句要么全部执行，要么不执行<br>事务有四个基本特性分别是：隔离性，原子性，一致性和持久性。<br>隔离性是保证事务与事务之间互不干扰<br>原子性是指事务为一个最小单位，不可分割<br>一致性是指事务执行前后数据一致<br>持久性指事务被提交后，他对数据库的改变是永久的</p></div></details><h4 id="并发给事务带来了哪些问题"><a href="#并发给事务带来了哪些问题" class="headerlink" title="并发给事务带来了哪些问题"></a>并发给事务带来了哪些问题</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>可能会出现脏读，不可重复读和幻读等问题<br>脏读是A事务在修改一个数据，B事务读取到修改后的数据，A事务发生回滚，B事务读取到了一个脏数据，与数据库的数据不一致，这就是脏读<br>不可重复读，A事务在修改一个数据，B事务在数据修改前后分别读取这个数据，读取到的数据不一样，这就是不可重复读<br>幻读，A事务在增添数据，B事务在增添前后读取数据，先失败后成功，就好像出现了幻觉一样</p></div></details><h4 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>有读取未提交，读取已提交，可重复读和可串行化四种隔离级别<br>读取未提交可能会出现脏读，不可重复读和幻读<br>读取已提交可能会出现不可重复读和幻读<br>可重复读可能会出现幻读<br>可串行化不会出现并发问题，但是效率最低</p></div></details><h4 id="事务隔离是靠什么实现的"><a href="#事务隔离是靠什么实现的" class="headerlink" title="事务隔离是靠什么实现的"></a>事务隔离是靠什么实现的</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>靠锁和MVCC即多版本并发控制实现的<br>读已提交隔离和可重复读主要依靠MVCC实现，串行化主要是靠锁来实现，但读已提交和可重复读也使用了锁来避免一些并发问题。<br>比如在读已提交中，如果事务对数据进行修改那么则会对数据短暂的加上独占锁，防止脏读的出现。<br>在可重复读中通过加间隙锁来降低幻读出现的可能性</p></div></details><h4 id="为什么有了间隙锁还是可能会出现幻读的情况"><a href="#为什么有了间隙锁还是可能会出现幻读的情况" class="headerlink" title="为什么有了间隙锁还是可能会出现幻读的情况"></a>为什么有了间隙锁还是可能会出现幻读的情况</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>间隙锁主要是针对索引记录进行加锁，如果有一些没有针对索引的操作那么依然可能会出现幻读的问题</p></div></details><h3 id="MySQL日志了解过吗"><a href="#MySQL日志了解过吗" class="headerlink" title="MySQL日志了解过吗"></a>MySQL日志了解过吗</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>了解过redo log，bin log和undo log<br>redo log是归档日志，是InnoDB特有，用于保证事务的持久性<br>bin log记录了所有对MySQL数据库的修改操作，可以用于数据库的主从复制<br>undo log是回滚日志，所有事务做出的修改都会先记录到回滚日志中，并且先于数据存储到磁盘中，当需要进行回滚时则查询回滚日志进行事务回滚</p></div></details><h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><h3 id="为什么要使用Redis做缓存"><a href="#为什么要使用Redis做缓存" class="headerlink" title="为什么要使用Redis做缓存"></a>为什么要使用Redis做缓存</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>主要是其高性能和高并发的特点。Redis主要是基于内存存储数据，对数据的访问速度非常快。Redis能够处理高并发的需求主要是因为他是单线程，不需要额外的资源进行线程切换和同步，并使用IO多路复用来处理请求提高效率</p></div></details><h3 id="Redis的基本数据结构有哪些"><a href="#Redis的基本数据结构有哪些" class="headerlink" title="Redis的基本数据结构有哪些"></a>Redis的基本数据结构有哪些</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>String、List、Hash、Set、SortedSet</p></div></details><h3 id="Redis的持久化方式"><a href="#Redis的持久化方式" class="headerlink" title="Redis的持久化方式"></a>Redis的持久化方式</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>Redis支持两种持久化方式，RDB快照和AOF只追加文件。</p><p>RDB快照是在一个时间点上记录内存上的数据，从而对其进行备份。其备份的格式是二进制文件，所以能够很快的对备份文件进行数据还原</p><p>AOF只追加文件会记录每一条会更改Redis中的数据的指令，并在设定的时间内将指令写入备份文件中，他能够相对实时的对Redis数据进行备份，且备份文件的可读性比RDB快照要强</p></div></details><h3 id="如何保证缓存和数据库一致-缓存读写模式"><a href="#如何保证缓存和数据库一致-缓存读写模式" class="headerlink" title="如何保证缓存和数据库一致(缓存读写模式)"></a>如何保证缓存和数据库一致(缓存读写模式)</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>旁路缓存模式，在更新数据的时候，先删除缓存中的数据再去数据库中更新数据。读取数据时先从缓存中读取数据，如果缓存中没有数据则去数据库中读取数据并将数据写入缓存中</p></div></details><h3 id="Redis中的常见问题"><a href="#Redis中的常见问题" class="headerlink" title="Redis中的常见问题"></a>Redis中的常见问题</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>缓存中的大量数据在同一时间失效，导致后续请求全部打在数据库中造成数据库宕机。<br>解决办法：不设置数据失效时间、设置不同的失效时间</p></div></details><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>某个热点数据失效，于此同时又有大量请求访问这个数据，此时这些访问就会全部请求数据库，给数据库造成压力<br>解决办法：不设置失效时间，或者设置较长的失效时间，让失效时间大于热点时间；使用互斥锁，限制访问数据库的线程数量。</p></div></details><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>某个数据在缓存和数据库中都不存在，但仍然有大量的请求访问这个数据，从而造成数据库压力过大。这种请求往往来自黑客的攻击<br>解决办法：校验请求，拦截非法请求；使用布隆过滤器，如果数据不存在则直接返回结果；在缓存中存储空数据，并设置较短的失效时间</p></div></details><h5 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h5><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>布隆过滤器是基于hash函数和位数组实现的。当我们向布隆过滤器中添加一个元素时，首先用K个不同的hash函数算出其hash值，然后在位数组中对应的位置置1。查找一个元素是否存在则检查这个元素不同hash值对应位置的位数组是否为1，如果都为1则存在，反之不存在。<br>布隆过滤器的占用空间很小，并且查询速度很快，但他有可能会误判，这是由于不同的元素可能有相同的hash值导致的</p></div></details><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建线程有哪些方式"><a href="#创建线程有哪些方式" class="headerlink" title="创建线程有哪些方式"></a>创建线程有哪些方式</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>线程创建有四种方式<br>1.继承Thread类并重写run()方法，然后调用start()方法启动<br>2.实现Runnable接口并实现run()方法，然后将该实例对象传入Thread构造方法中创建线程对象。<br>3.实现Callable接口并实现call()方法，并将该实例传入FutureTask构造方法中，创建FutureTask对象并将其传入Thread构造方法中创建线程对象<br>4.通过线程池来创建线程。</p></div></details><h3 id="几种线程创建方式的区别"><a href="#几种线程创建方式的区别" class="headerlink" title="几种线程创建方式的区别"></a>几种线程创建方式的区别</h3><h4 id="直接继承Thread类和实现Runnable接口的区别"><a href="#直接继承Thread类和实现Runnable接口的区别" class="headerlink" title="直接继承Thread类和实现Runnable接口的区别"></a>直接继承Thread类和实现Runnable接口的区别</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>Java中只能单继承，直接继承Thread类可扩展性较差；实现Runnable接口相对来说可扩展性强一些</p></div></details><h4 id="Runnable接口和Callable接口的区别"><a href="#Runnable接口和Callable接口的区别" class="headerlink" title="Runnable接口和Callable接口的区别"></a>Runnable接口和Callable接口的区别</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>实现Callable接口的方式可以让线程返回一个结果，从而实现线程之间的数据共享。Runnable不具备这样的功能</p></div></details><h4 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h4><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>使用线程池可以避免频繁的线程创建和销毁，可以重复的利用已有的线程，提高性能</p></div></details><h3 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>有两种方式可以创建线程池，使用Executors类通过线程池工厂的方式创建和手动创建。</p><p>使用Executors类中提供的newFixedThreadPool()、newCachedThreadPool()、newSingleThreadLocal()等静态方法创建不同类型的线程池</p><p>如果是手动创建线程池，即使用ThreadPoolExecutor()构造方法，通过手动传入参数来创建线程池</p></div></details><h3 id="线程池的几个核心参数有哪些"><a href="#线程池的几个核心参数有哪些" class="headerlink" title="线程池的几个核心参数有哪些"></a>线程池的几个核心参数有哪些</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>核心线程数，最大线程数，任务队列，线程存活时间，拒绝策略</p><p>当有新任务来的时候，如果线程池当前的线程数量小于核心线程数量，那么线程池就会创建一个新的线程来处理这个任务，即使其他线程仍处于空闲状态；当所有核心线程都在执行任务，那么新来的任务会加入到任务队列中，等待核心线程空闲之后再执行；如果任务队列已经满了，但线程池的线程数量小于最大线程数，那么线程池就会创建新的线程来执行这个任务，如果当前线程数大于核心线程数量，多余的线程会在空闲时间超过存活时间后被终止掉；如果正在工作的线程数量已经达到最大线程数，新任务到来的时候则会执行拒绝策略</p></div></details><h3 id="线程池的拒绝策略有哪些"><a href="#线程池的拒绝策略有哪些" class="headerlink" title="线程池的拒绝策略有哪些"></a>线程池的拒绝策略有哪些</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>直接终止策略、调用者执行策略、直接丢弃策略、丢弃最早任务策略</p><p>直接终止策略会抛出一个异常来终止任务的处理</p><p>调用者执行策略会让调用excute()方法的线程来执行这个任务</p><p>直接丢弃策略会直接丢掉这个任务不做处理</p><p>丢弃最早任务策略会丢弃任务队列中最前面的任务</p></div></details><h3 id="线程池的任务队列有哪些，都有什么特性"><a href="#线程池的任务队列有哪些，都有什么特性" class="headerlink" title="线程池的任务队列有哪些，都有什么特性"></a>线程池的任务队列有哪些，都有什么特性</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>线程池的任务队列有直接交付队列、有限任务队列和无限任务队列</p><p>直接交付队列(SynchronousQueue)不会存储任何任务，如果有新任务到来，那么线程池会立即处理这个任务，如果线程数量已经达到核心线程数，那么线程池会立即新建一个线程来处理这个任务。在需要快速执行任务的场景下使用</p><p>有界任务队列(ArrayBlockingQueue)能够存储有限数量的任务。在需要控制处理速度场景下使用</p><p>无界任务队列(LinkedBlockingQueue)能够存储无限数量的任务。在任务量很多的场景下使用</p></div></details><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>ThreadLocal是线程的私有变量，用来存储线程的私有信息。一个线程的ThreadLocal变量只能由这个线程进行操作，从而避免了线程安全问题。</p></div></details><h3 id="ThreadLocal的底层了解吗"><a href="#ThreadLocal的底层了解吗" class="headerlink" title="ThreadLocal的底层了解吗"></a>ThreadLocal的底层了解吗</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>ThreadLocal底层是由ThreadLocalMap实现的，其数据结构类似于HashMap，每一个ThreadLocal变量都是一个键值对并以Entry的形式封装，存储在ThreadLocalMap中。</p></div></details><h3 id="为什么要使用ThreadLocal"><a href="#为什么要使用ThreadLocal" class="headerlink" title="为什么要使用ThreadLocal"></a>为什么要使用ThreadLocal</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>在并发环境下，涉及到线程需要维护一个与其他线程相互隔离的私有变量的时候就可以考虑使用ThreadLocal。</p></div></details><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="Spring-SpringBoot"><a href="#Spring-SpringBoot" class="headerlink" title="Spring/SpringBoot"></a>Spring/SpringBoot</h2><h3 id="谈谈你对Spring框架的理解"><a href="#谈谈你对Spring框架的理解" class="headerlink" title="谈谈你对Spring框架的理解"></a>谈谈你对Spring框架的理解</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>Spring是一个轻量级的，非侵入式的编程框架，他给我们提供了一个可重用，高性能，模块化的编程和配置模式。他有两个核心的组件SpringIoC和SpringAOP。<br>IoC即控制反转，他的核心思想就是让我们把对象创建和管理交给IoC容器来处理，这样我们就不需要关心对象之间的相互依赖关系，在需要使用对象的时候直接从IoC容器里面取就可以了。从而把更多的精力放在业务逻辑上，提高开发效率<br>AOP即切面编程，他让我们在不改变原有代码的基础上，通过定义切面来实现对系统功能的增强，比如日志记录、性能监控等待。<br>Spring还提供了SpringMVC，SpringBoot等一些功能模块，从而帮助我们进行快速开发<br>总之Spring框架就是为了提高编程效率而存在，让我们把更多的精力放在业务逻辑上面</p></div></details><h3 id="SpringAOP的底层是如何实现的"><a href="#SpringAOP的底层是如何实现的" class="headerlink" title="SpringAOP的底层是如何实现的"></a>SpringAOP的底层是如何实现的</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>SpringAOP是基于动态代理实现的，在SpringAOP中，当Bean被容器实例化之后，Spring会动态创建一个Bean的代理对象，代理对象会拦截实例对象的方法请求，从而控制这个实例对象，在方法执行的前后增加一些逻辑，例如权限检测和性能监测等等。</p></div></details><h3 id="谈一下你对SpringMVC的理解"><a href="#谈一下你对SpringMVC的理解" class="headerlink" title="谈一下你对SpringMVC的理解"></a>谈一下你对SpringMVC的理解</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>SpringMVC是Java Web应用中的一个框架，他采用MVC设计模式来处理Web请求，其中M，Model代表模块，主要负责业务数据和业务逻辑；V，View代表视图，负责前端页面；C，Controller代表控制器，用于处理前端的请求。</p><p>在SpringMVC框架中，请求由DispatcherServlet接收，并将其分发给相应的处理器，即controller。controller处理请求，并完成一系列业务逻辑后，将返回结果封装为ModelAndView对象返回给DispatcherServlet，DispatcherServlet将ModelAndView对象解析为具体的响应数据后再返回给客户端</p><p>除此之外SpringMVC还提供了很多注解和静态工具类来简化代码的编写，提高开发效率 </p></div></details><h3 id="为什么要使用SpringBoot"><a href="#为什么要使用SpringBoot" class="headerlink" title="为什么要使用SpringBoot"></a>为什么要使用SpringBoot</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>在使用Spring整合其他框架或技术的时候，我们需要进行大量的XML文件配置，还需要关注版本依赖等一系列问题。SpringBoot在Spring的基础上，采用了约定大于配置的思想，提供了一系列默认配置和自动装配的功能，从而大大提高了开发效率。</p></div></details><h3 id="SpringBoot的自动装配是怎么实现的"><a href="#SpringBoot的自动装配是怎么实现的" class="headerlink" title="SpringBoot的自动装配是怎么实现的"></a>SpringBoot的自动装配是怎么实现的</h3><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>SpringBoot的自动装配主要是通过注解和starter模块实现的。Springboot通过路径扫描读取到starter模块的META-INFO下的spring.factories文件，并从此文件中找到配置类，再通过一系列条件注解，例如@ConditionalOnMissingClass、@ConditionalOnBean等等，从配置类中获取当前需要使用的Bean注入到IoC容器当中，从而完成自动配置。SpringBoot对这一模块的封装很深，但主要的逻辑就是靠上述过程实现的。</p></div></details><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h2><details class="toggle" ><summary class="toggle-button" style="">我的回答</summary><div class="toggle-content"><p>代理模式通过代理对象控制原始对象，从而对原始对象进行功能上的控制和加强，代理模式又分为静态代理模式和动态代理模式。<br>静态代理模式需要创建一个代理类并且实现原始类的接口，同时还需要有原始类的一个实例，然后通过对原始对象的控制实现代理功能<br>动态代理模式不需要代理类实现原始类的接口，它依靠反射机制，在运行时动态的创建代理类，从而控制原始对象</p></div></details>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;美团面试过后进行的学习方式的调整，每个知识点看完之后还得用自己的语言将其串通才行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的回答隐藏起来，方便自我检测&lt;/p&gt;
&lt;details class=&quot;toggle&quot; &gt;&lt;summary class=&quot;t</summary>
      
    
    
    
    <category term="面试" scheme="https://kallenblue.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>美团后端开发工程师暑期实习一面</title>
    <link href="https://kallenblue.github.io/2023/03/28/%E9%9D%A2%E8%AF%95/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/"/>
    <id>https://kallenblue.github.io/2023/03/28/%E9%9D%A2%E8%AF%95/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/</id>
    <published>2023-03-28T12:41:49.000Z</published>
    <updated>2023-03-30T07:14:43.395Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面试官：讲一下项目的背景，目标是什么样的，你在其中做了什么，最后拿到了一个什么样的结果</strong></p><p><strong>面试官：你做这个项目的过程中，有什么技术难点？</strong></p><p><strong>面试官：SpringBoot框架都提供了哪些特性？</strong></p><p><strong>面试官：聊一聊SpringBoot如何自动化装配</strong></p><p><strong>面试官：详细说一下项目中怎么使用ThreadLocal的</strong></p><p><strong>面试官：说一下线程同步是什么意思，然后线程同步都有哪些实现方式？</strong></p><p><strong>面试官：JDK1.8的一些新特性</strong></p><p><strong>面试官：了解过Java的内存模型吗？</strong></p><p><strong>面试官：垃圾回收算法你知道吗？</strong></p><p><strong>面试官：这些回收算法对应的垃圾回收器了解过吗？</strong></p><p><strong>面试官：Java的拆箱和装箱了解过吗？</strong></p><p><strong>面试官：InnoDB了解过吗？</strong></p><p>然后就是在线编程了</p><p>这次的面试让我感觉非常受挫，没有组织好语言，回答的时候逻辑混乱，很多知识点都没讲好。我觉得关键就在于平时没有刻意的去训练，没有去练习如何组织语言。<br>最后在线编程的时候因为心态的原因，卡了很久，我心里甚至在想能不能早点结束了，太失败了。记录下这次面试，从今以后我每天都会给自己给自己准备几道面试题，然后不去参考任何资料的去回答。不然很多知识都是看着会，要讲的时候就不会了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;面试官：讲一下项目的背景，目标是什么样的，你在其中做了什么，最后拿到了一个什么样的结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：你做这个项目的过程中，有什么技术难点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：SpringBoo</summary>
      
    
    
    
    <category term="面试" scheme="https://kallenblue.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里研发工程师JAVA暑期实习二面</title>
    <link href="https://kallenblue.github.io/2023/03/16/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JAVA%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/%E9%98%BF%E9%87%8C%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JAVA%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2/"/>
    <id>https://kallenblue.github.io/2023/03/16/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JAVA%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/%E9%98%BF%E9%87%8C%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JAVA%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E4%BA%8C%E9%9D%A2/</id>
    <published>2023-03-16T08:35:00.000Z</published>
    <updated>2023-03-20T13:52:14.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二面就安排在一面的两天后，本来面试官打算昨天就给我面的，但是昨天晚上要笔试，于是改在了今天下午。</p><p>其实我也很想尽量晚些再二面，这样的话能够多做些准备。一面的时候，面试官问我JVM的知识，我没答好，于是就花了一天的时间学习了一下JVM，看了内存区域，垃圾回收机制以及类加载过程。还有一些知识就没来得及看了。但面完之后我又想了想，其实这些都无所谓，重要的是自己的心态。总会有没有准备的东西，面试也不是考试，是一个双向选择的过程，双方都有自己想要的东西，重在一个交流。</p><p>二面的面试官给我一种很亲切的感觉，和他交流就像是和一位直系学长交流一样，整个面试过程都很轻松，面试氛围很好。</p><h1 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h1><blockquote><p>省略部分我的回答，主要的是面试官的提问，而且一些回答也不值得一提</p></blockquote><p><strong>面试官：昨天笔试感觉如何？</strong></p><p>我：(说了一下笔试情况，并把自己当时的一些想法说了出来)</p><p><strong>面试官：先简单介绍一下自己吧</strong></p><p>我：(其实我感觉自我介绍还是蛮重要的，我是提前准备了几个点给面试官介绍自己，其实就是大致把自己的简历总结一下，毕竟是给面试官的第一印象，尽量像朋友一样)</p><p><strong>面试官：我看你写了三个项目在简历里面，选一个比较有特点的讲一下吧</strong></p><p>我：(讲了一下我的健康码项目)</p><p><strong>面试官：你们当时做这个健康码系统的发起背景是什么？</strong></p><p><strong>面试官：我看你这里面也提到了一些相关的技术，你们redis是怎么设计的，里面存了什么内容？</strong></p><p><strong>面试官：你有想过用类似redis的产品来替换redis吗？</strong></p><p>我：(本身没怎么准备redis以外的NoSQL，怕之后面试官问到，绕开了这个问题)</p><p><strong>面试官：在不考虑性能的情况下，用数据库去实现，能满足你们的需求吗？</strong></p><p><strong>面试官：从成本上考虑的话，redis的成本会比db高很多诶</strong></p><p>我：(提到redis可以采用分布式存储数据，但后来想了想不应该往这上面答，应该从为什么要使用redis这上面来答，关于这点我还需学习，后续会补上这部分的空缺)</p><p><strong>面试官：redis采用的是单线程单进程的逻辑，但为什么它的性能这么好</strong></p><p>我：(提到了高速缓存，后面面试官又追问为什么要采用单线程逻辑，我没答上来，有点可惜，之前看过这一部分，但没想到是重点，就直接带过了)</p><ul><li><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB">参考答案</a></li></ul><p><strong>面试官：乐观锁和悲观锁的区别是什么？</strong></p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">参考答案</a></li></ul><p><strong>面试官：分布式锁有去了解过吗？</strong></p><p>我：(由于我没有把重点放在分布式上面，所以没有去看这部分的内容，但是前面又提到了分布式，没办法，只好再次绕开。所以知识永不嫌多啊，之后还得加强复习)</p><p><strong>面试官：如何创建一个线程池？</strong></p><p>我：(二面再次来到线程池这里，说明线程池很重要，还好这部分我掌握得比较好)</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0">参考答案</a></li></ul><p><strong>面试官：线程池的核心参数有哪些？</strong></p><p>我：(总的来说回答的不错，但是中途有点纰漏，就是线程池处理任务的顺序搞错了，当时以为线程是先达到最大线程数之后再移入队列，但应该是先到达核心线程数，再进任务队列，最后才是最大线程数)</p><p><strong>面试官：Java常见的集合有哪些？</strong></p><p><strong>面试官：怎么去创建一个不可修改的集合？</strong></p><p>我：(被这个问题问住了！我脱口即答加final。这个知识点得去了解一下)</p><ul><li><a href="https://blog.csdn.net/fanbaodan/article/details/103237298">参考答案</a></li></ul><p><strong>面试官：怎么对比两个对象是不是同一个对象？</strong></p><ul><li><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#object">参考答案</a></li></ul><p><strong>面试官：我想实现对象的深克隆，有什么办法吗？</strong></p><p>我：(只答上了重写clone方法并且递归调用,后来在面试官的引导下想到了用对象的序列化实现，所以我说这个面试官很好，很愿意和面试者聊。之前确实只是了解过深拷贝，没有考虑实现方法有哪些。又记下这个点，继续努力)</p><ul><li><a href="https://blog.csdn.net/qq_39327985/article/details/100116148">参考答案</a></li></ul><p><strong>面试官：ThreadLocal存在的意义是什么？</strong></p><p><strong>面试官：线程上下文参数传递不也能实现ThreadLocal的功能吗？为什么要用这个东西啊？</strong></p><p>我：(现在回放我还是没理解面试官说的那个上下文参数是个啥，是session吗？当时真该问清楚的，如果是关于这个的话就是类似于这个<a href="https://blog.csdn.net/z394642048/article/details/105382603?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-105382603-blog-83594799.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-105382603-blog-83594799.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1">答案</a>)</p><p><strong>面试官：讲讲你是如何使用网络爬虫爬取道具的？</strong></p><p>我：(真没想到面试官会问这个，这是之前王者荣耀一个荣耀水晶秒杀活动，我当时帮周围的朋友一人抢了2000Q币，感觉挺有意义的，就写上去了)</p><p><strong>面试官：你有想过怎么阻止这种情况发生呢？</strong></p><p>我：(？笑了，我阻止我自己！但为了过面试，还是讲了一些反爬操作)</p><p><strong>面试官：(问了一个逻辑题？第一次遇到这种题)机械时钟3点15的时候，时针和分针的夹角是多少？</strong></p><p>我：(讲了一下自己的逻辑，靠，最后有些紧张，算错了，30/4=28.5？？？没错，我当时就是这样说的，我都不知道是怎么来的，面试官还问我28.5怎么来的，我刚开始还没反应过来，最后一波还脑抽了，真服了，巨尴尬)</p><p><strong>面试官：还有什么想问的？</strong></p><p>我：后续还有什么过程？</p><p>面试官告诉我还有三面，他老板还要给我面一次，然后还有一次HR面。我最开始以为只有两面技术面，大意了</p><p>我：能给我一些方向和建议吗</p><p>面试官让我再多加强一些理论知识，多去看看源码</p><p>面试到这里就结束了</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>现在是3月17号的凌晨1点，我本来打算明天再写面经的，今天实在是太忙了，但是明天还有其他事情要做，而且当天的记忆最为深刻，所以还是加了点班写下了。</p><p>其实我感觉这次面试挺失败的，很多地方都没答上来，但这个面试官给我的感觉很好，很亲切，就像我的直系学长一样，我没答上来的时候也没有很尴尬的感觉，氛围一直都很好。不管最后结果怎么样，我觉得我都能接受，每一次面试都是一次收获</p><p>总结完了，接下来又该前进了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;二面就安排在一面的两天后，本来面试官打算昨天就给我面的，但是昨天晚上要笔试，于是改在了今天下午。&lt;/p&gt;
&lt;p&gt;其实我也很想尽量晚些再二面，</summary>
      
    
    
    
    <category term="面试" scheme="https://kallenblue.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>阿里研发工程师JAVA暑期实习一面</title>
    <link href="https://kallenblue.github.io/2023/03/14/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JAVA%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/%E9%98%BF%E9%87%8C%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JAVA%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/"/>
    <id>https://kallenblue.github.io/2023/03/14/%E9%9D%A2%E8%AF%95/%E9%98%BF%E9%87%8C%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JAVA%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/%E9%98%BF%E9%87%8C%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88JAVA%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/</id>
    <published>2023-03-14T07:02:43.000Z</published>
    <updated>2023-03-16T16:20:51.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先说一下我自己的情况"><a href="#先说一下我自己的情况" class="headerlink" title="先说一下我自己的情况"></a>先说一下我自己的情况</h1><p>我就读于湖南大学，软件工程专业，现在大三下<br>很巧的是，我在大二的时候就在相同的时间面过相同的部门和相同的岗位，所以我没有做笔试就直接让我去面试了。我当时还纳闷，为什么阿里如此高效。等我面完之后面试官才发现我没做笔试，然后反手就给了我笔试链接。<br><a href="https://imgse.com/i/pplWlSx"><img src="https://s1.ax1x.com/2023/03/14/pplWlSx.png"></a></p><h1 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h1><blockquote><p>在面试之前我心里很清楚自己有哪些地方没有准备好，最主要的就是JVM这一块儿，然后是Spring和Mybatis框架这一块儿(后面果然问到了JVM和Spring)。所以就想着要绕开这一部分，有时间的话还是要多准备，但如果被问到了也一定要实事求是，然后绕到自己熟悉的技术点去</p></blockquote><p><strong>面试官：先简单介绍一下你自己吧</strong></p><p>我：(自我介绍，主要讲了自己学习Java的历程)</p><p><strong>面试官：双等号和equals的区别</strong></p><p>我：正常回答</p><ul><li><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB">参考答案</a></li></ul><p><strong>面试官：String、StringBuffer和StringBuilder的区别</strong></p><p>我：正常回答</p><ul><li><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string">参考答案</a></li></ul><p><strong>面试官：Java虚拟机方面有了解过吗？</strong></p><p>我：坦白自己没有深入了解，并说明自己后续会深入学习</p><p><strong>面试官：那我问你几个简单的，看你知不知道，类加载机制知道大致流程吗</strong></p><p>我：(没有讲明白，但是把自己知道的东西讲了，能讲的尽量讲了)</p><ul><li><a href="https://javaguide.cn/java/jvm/class-loading-process.html">参考答案</a></li></ul><p><strong>面试官：你项目中有接触过JVM吗</strong></p><p>我：(我知道他指的是JVM优化，但我确实也没用过，所以就说了自己没用过)</p><p><strong>面试官：(面试官没有为难我，开了另一个话题)那个设计模式你了解得这么样</strong></p><p>我：答了单例模式和工厂模式，具体答了单例模式的一些实现细节(这一块儿我也是薄弱块儿，当时也就只看了单例模式和工厂模式)</p><ul><li><a href="https://javaguide.cn/system-design/design-pattern.html">参考答案</a></li></ul><p><strong>面试官：多线程这块儿你现在有涉及到吗</strong></p><p>我：(多线程这块准备的比较多，所以开始引导面试官向我准备比较充分的地方问)讲了多线程的很多特性</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">参考答案</a></li></ul><p><strong>面试官：你用过ThreadPoolExecutor类吗</strong></p><p>我：(发现开始问线程池这方面的知识了)回答了线程池的核心参数和饱和策略</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0">参考答案</a></li></ul><p><strong>面试官：关于Spring里的一些知识你了解过吗</strong></p><p>我：(开始问Spring，我知道这方面会比较复杂，很多知识点也比较深，由于没有充分准备，所以我赶紧把面试官往我熟悉的地方引入)讲了SpringIoC原理和AOP，然后顺便讲了讲拦截器</p><p><strong>面试官：技术问题就到这里，讲一下你比较有亮点的项目</strong></p><p>我：(开始讲项目了，这个我有提前准备，把项目中比较突出的技术讲了一下，特意提到了Redis，因为有所准备)</p><p><strong>面试官：Redis用在哪种场景下</strong></p><p>我：正常回答</p><p><strong>面试官：Redis修改的时候你是怎么操作的(指缓存过期)</strong></p><p>我：正常回答</p><ul><li><a href="https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0">参考答案</a></li></ul><p><strong>面试官：你缓存查不到了，数据库里也没有数据，然后用户又发送大量请求，你怎么考虑</strong></p><p>我：(立马意识到是在提<a href="https://xiaolincoding.com/redis/base/redis_interview.html#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">缓存穿透</a>，但我当时忘了应对措施了)跟面试官讲了一下缓存穿透，然后说自己在项目中忽略了这个问题，然后想了一下缓存穿透的应对措施，总之没有答好</p><p><strong>面试官：(面试官知道我不是很了解，说没事儿，这个不强求。然后问我在项目中最大的收获)</strong></p><p>我：我答了最大的收获是团队协作，使用git管理代码，还有代码规范</p><p><strong>面试官：你刚才介绍自己学习能力强，体现在哪方面呢？</strong></p><p>我：我提到了自己接触硬件编程，并且很快掌握的事情</p><p><strong>面试到这里差不多就结束了，然后面试官说看我这边笔试已经完成了吧？我直接问号，原来是因为去年面试的时候做的笔试，让面试官误以为我已经做了笔试，所以才出现先面试再笔试的情况</strong></p><p><strong>面试官：你还有什么想问的</strong></p><p>我：问了面试过程，然后就结束面试了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>赶紧恶补JVM，Spring和MVC的知识，原理一定要弄明白。面试还是要有所准备，但完全准备也是不太可能的，最好的方式就是边面边学。只有面了之后，你才知道自己真正缺的是什么东西。愿共勉！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;先说一下我自己的情况&quot;&gt;&lt;a href=&quot;#先说一下我自己的情况&quot; class=&quot;headerlink&quot; title=&quot;先说一下我自己的情况&quot;&gt;&lt;/a&gt;先说一下我自己的情况&lt;/h1&gt;&lt;p&gt;我就读于湖南大学，软件工程专业，现在大三下&lt;br&gt;很巧的是，我在大二的时候就</summary>
      
    
    
    
    <category term="面试" scheme="https://kallenblue.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>我不是很认可还有人没有使用ChatGPT</title>
    <link href="https://kallenblue.github.io/2023/03/10/%E9%9A%8F%E7%AC%94/%E6%88%91%E4%B8%8D%E6%98%AF%E5%BE%88%E8%AE%A4%E5%8F%AF%E8%BF%98%E6%9C%89%E4%BA%BA%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8ChatGPT/"/>
    <id>https://kallenblue.github.io/2023/03/10/%E9%9A%8F%E7%AC%94/%E6%88%91%E4%B8%8D%E6%98%AF%E5%BE%88%E8%AE%A4%E5%8F%AF%E8%BF%98%E6%9C%89%E4%BA%BA%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8ChatGPT/</id>
    <published>2023-03-10T06:51:24.000Z</published>
    <updated>2023-03-13T15:56:35.195Z</updated>
    
    <content type="html"><![CDATA[<p>先附上<a href="https://chat.openai.com/chat">ChatGPT</a>的网址<br>现在是2023年的3月10日，ChatGPT刚出来的时候是2022年11月30日，如果你还没有使用过ChatGPT就相当于90年代没有骑过自行车；00年代没有使用过手机；10年代没有上过网；20年代没有微信。我可以很确切的告诉你，你90%的正常问题，ChatGPT都可以帮你解决。</p><h1 id="ChatGPT注册"><a href="#ChatGPT注册" class="headerlink" title="ChatGPT注册"></a>ChatGPT注册</h1><p>首先第一步，懂的都懂，你得有梯子，这个可以自己去找，我用的是<a href="https://www.cutecloud.net/">萌云</a>，因为可以按流量购买，比较实用</p><p>然后需要一个国外的手机号，可以用<a href="https://sms-activate.org/cn/info/ChatGPT">sms-activate</a>来进行短信验证，这个上面是使用国外的虚拟号码，我第一次注册的时候很快就成功了，但是现在注册比较困难了，我今天尝试了一下，虚拟手机号老是收不到消息(注意要把国家编号给去掉)，然后你想多尝试几次，openAI不给你验证了，挺恶心的，搞了我很长时间。<br>虚拟号码如果没有使用他是会退钱的，不用担心超时没有收到短信</p><h1 id="我身边的人使用ChatGPT"><a href="#我身边的人使用ChatGPT" class="headerlink" title="我身边的人使用ChatGPT"></a>我身边的人使用ChatGPT</h1><p>当我给女朋友电脑上弄好ChatGPT后<br><img src="https://z4a.net/images/2023/03/13/e7f81ae5d05f40ea8b27cc7606d493e7.png" alt="在这里插入图片描述"><br><img src="https://z4a.net/images/2023/03/13/27e516e484d14e1ab74cbe853984f2fe.png" alt="在这里插入图片描述"><br><img src="https://z4a.net/images/2023/03/13/9cab3080695043e6886c9cf79c96d105.png" alt="在这里插入图片描述"><br>我女朋友的闺蜜也寻声而来<br><img src="https://z4a.net/images/2023/03/13/b0de6babed794c23980ea2aa7a0d5e78.png" alt="在这里插入图片描述"><br>你可以把ChatGPT当成是一个朋友，老师，教科书，纠错员，甚至是宠物。。。<br><img src="https://z4a.net/images/2023/03/13/42dd840a2b5040ea9369fc0f5d61c538.png" alt="在这里插入图片描述"><br>ChatGPT能够记录每一次的会话，每个会话确定一个主题会让ChatGPT从此次会话中学习，从而进化成不同类型的小chat。在一开始，他是一个万能的百科全书，集结了互联网上所有的知识，在你和他的特定语境中又能逐渐学习，最后演变成你希望的样子。谁还不希望自己身边能够有一个哆啦A梦？</p><h1 id="我对ChatGPT的理解"><a href="#我对ChatGPT的理解" class="headerlink" title="我对ChatGPT的理解"></a>我对ChatGPT的理解</h1><p>在我看来，ChatGPT是互联网实体化的一个东西，就像是互联网上的所有东西凝聚了起来，具象化为了一个人，你可以和他进行交流，他无所不知(他很聪明，会隐藏一些事情，比如人为规定的一些道德准则)<br><img src="https://z4a.net/images/2023/03/13/96620da0f2ae47a88d4df05ac946a600.png" alt="在这里插入图片描述"></p><p>现在每个人都有一部手机，我的一位老师用”人的一个器官”来形容现在的手机，当ChatGPT普及之后，他也必定会影响我们的生活，成为我们生活的一部分，影响着我们。</p><p>说白了，ChatGPT提供给我们的东西就是互联网上早已存在的东西，只是现在，我们能够通过对话的方式，很轻松的获取到这些信息。在ChatGPT还没出现的时候，我们是靠自己，通过互联网探索整个世界；在他诞生之后，就有了一位向导，能够与之交谈的向导，带领我们触摸整个世界</p><h1 id="ChatGPT对我的帮助"><a href="#ChatGPT对我的帮助" class="headerlink" title="ChatGPT对我的帮助"></a>ChatGPT对我的帮助</h1><p>我的win10计算机老是自动更新win11，但是每次更新电脑都会死机，让人很头痛，之前我自己在网上找了很多办法都没有解决这个问题，然后去电脑城找技术人员帮忙，花了100块钱，3天之后问题复现。。。这让我十分恼火，就像是毛衣里的头发，时不时会扎着你，让你不舒服，但是你就是处理不完。后来，我向ChatGPT询问这个问题，只用了10分钟！解决了我长久以来的困扰！！！<br><img src="https://z4a.net/images/2023/03/13/4859c303b3604630bb496292adebe2f1.png" alt="在这里插入图片描述"></p><p>当然，帮我做学校作业，帮我检查代码这些事情业都是小菜一碟了。以后遇到什么技术问题，不用再将问题复述到搜索引擎上，查到之后再一一筛选了，直接去问小chat！他的效率绝对比你自己在搜索引擎上搜索的效率高</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>一个时代有一个时代的产物，要能够抓住时代产物，能够灵活运用时代的产物，帮助自己，便利自己，提升自己，只有这样才能跟紧时代，走在时代的前面，最后才能带领时代。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先附上&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;ChatGPT&lt;/a&gt;的网址&lt;br&gt;现在是2023年的3月10日，ChatGPT刚出来的时候是2022年11月30日，如果你还没有使用过ChatGPT就相当于90年代没有骑过自行车；00年代</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>并发编程</title>
    <link href="https://kallenblue.github.io/2023/01/19/%E7%82%B9%E6%BB%B4/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://kallenblue.github.io/2023/01/19/%E7%82%B9%E6%BB%B4/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2023-01-19T08:18:47.000Z</published>
    <updated>2023-03-14T09:56:44.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于Java的多线程，其实我在很早之前就开始使用了，那时候还在大一，在蓝杰跟着做项目，很单纯的使用，不知道原理。但Java多线程涉及到的知识点很多，有些也比较复杂，值得系统的再学习一次。</p></blockquote><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程实际上是一个程序在计算机上运行的一个载体，操作系统会为每一个进程分配内存空间。一个程序可以同时启动多次，运行多个进程，比如QQ、记事本等，也有只能启动一个进程的程序，比如爱奇艺。当然这些都是内部自行定义的</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程的子集，一个进程是由一个以上的线程构成的，如果把进程比喻成一项工作，那么线程就是完成这项工作的人</p><h2 id="进程通信和线程通信"><a href="#进程通信和线程通信" class="headerlink" title="进程通信和线程通信"></a>进程通信和线程通信</h2><p>进程之间的通信较为复杂，不同计算机上的进程通信需要靠互联网和一些通信协议，比如TCP</p><p>同一进程下的线程之间的通信可以依靠进程，因为他们共享内存空间，同属于一个进程的线程可以比较方便地进行通信</p><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>并行是指在同一时间，同时运行（只有多核才能并行）</p><p>并发是指同一时间段，同时运行（轮流调度运行）</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>一个线程是由一连串的程序码构成的，在同步的情况下，必须等待一个线程执行完之后再执行另一个线程，程序码按顺序执行</p><p>异步则是不等待一个线程执行完成就切换下一个线程运行或者同时运行多个线程，总之就是线程之间不会进行相互等待</p><h2 id="线程的运行细节"><a href="#线程的运行细节" class="headerlink" title="线程的运行细节"></a>线程的运行细节</h2><p>程序启动，JVM加载程序的函数方法到方法区，并在栈空间中分配main线程的空间，并带有一个程序计数器，记录当前执行的代码，JVM会按照计数器所指定的代码运行，如果有新对象的创建则在堆中创建对象，并用栈中方法的局部变量引用堆中的对象。如果存在方法的调用则会在栈空间中创建一个新的栈空间（ps:栈帧）为方法服务，方法返回后程序计数器会指向方法调用的位置，再次按照之前的顺序运行代码</p><h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="Java线程启动"><a href="#Java线程启动" class="headerlink" title="Java线程启动"></a>Java线程启动</h2><h3 id="重写Thread中的run"><a href="#重写Thread中的run" class="headerlink" title="重写Thread中的run"></a>重写Thread中的run</h3><p>重写Thread中的run方法后创建Thread对象，再调用start方法即可启动线程，这是最基本的启动方法</p><h3 id="通过Runnable类启动线程"><a href="#通过Runnable类启动线程" class="headerlink" title="通过Runnable类启动线程"></a>通过Runnable类启动线程</h3><p>Runnable类也有一个run方法，重写后创建Runnable对象，并将对象传给Thread类的构造函数中然后通过Thread对象的start方法启动线程。这样可以将线程执行内容和线程分开，虽然我目前不知道这有什么用，看视频上说是可以更好的配合一些api</p><h3 id="FutureTask配合Thread"><a href="#FutureTask配合Thread" class="headerlink" title="FutureTask配合Thread"></a>FutureTask配合Thread</h3><p>目前只是知道有这个，这种方式启动的线程可以有返回值</p><h2 id="start和run"><a href="#start和run" class="headerlink" title="start和run"></a>start和run</h2><p>直接调用run方法并不会启动新的线程去运行run方法中的代码，结果还是main线程去运行</p><p>start方法才会另起一个线程去执行run方法中的内容</p><p>一个线程的start方法不能调用两次，否则会报错</p><h2 id="sleep和yield"><a href="#sleep和yield" class="headerlink" title="sleep和yield"></a>sleep和yield</h2><p>线程调用sleep方法会使线程进入Time Waiting状态，cpu不再为其分配时间片，sleep方法会接收一个时间参数，等待时间达到这个参数后才会重新去竞争时间片，注意，不会立即获得时间片而是去竞争。TimeUnit的sleep方法具有更好的可读性，但是最终也是使用的sleep方法</p><p>线程的interrupt方法会直接唤醒睡眠的线程使其立即去竞争时间片，同时线程抛出被打断的异常</p><p>线程调用yield方法后会使线程进入Runnable状态，即放弃自己当前的时间片，但有可能该线程又能够立即获得新的时间片，所以不保证能够暂停线程</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>调整线程的优先级会给cpu一个调度提示，尽可能多的去调用优先级高的线程，但这仅仅是一种提示，最终的决策还是由操作系统来决定，yield方法也是如此，都是靠的操作系统</p><h3 id="sleep运用的一个小案例"><a href="#sleep运用的一个小案例" class="headerlink" title="sleep运用的一个小案例"></a>sleep运用的一个小案例</h3><p>在死循环中使用sleep睡眠一小段时间可以避免单核CPU使用率到达100%，在不影响程序功能的情况下提高计算机的性能</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join是保证线程同步的一个方法，一个线程调用了join方法则需要等待线程内的方法结束后才会继续向后运行。join方法可以带参数，参数为单位为毫秒的一个时间，表示最多等待参数时间，超过时间即使线程没有执行完成也会向后运行</p><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>interrupt方法可以标记线程的运行状态为被打断状态，正常的线程被打断后，会使isInterrupted（即判断线程是否被打断）为true，但线程处于sleep，wait或join状态的线程被打断后会抛异常，isInterrupted仍然为false。</p><p>interrupt方法并不会直接使线程停止运行，而是打上一个标记，这样的好处就是可以自行处理被打断的线程，安排其被打断后需要做的事情(例如释放资源)。而处于阻塞状态的线程被打断后会抛出异常，可以在异常处理中进行后续安排</p><h4 id="isInterrupted和interrupted"><a href="#isInterrupted和interrupted" class="headerlink" title="isInterrupted和interrupted"></a>isInterrupted和interrupted</h4><p>isInterrupted不会重置打断标记，而interrupted会重置标记为false</p><h4 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h4><p>这是对interrupt的一种常见应用，程序进入无限循环，每一次进行了相应操作后睡眠一段时间。在每次循环前检查打断标记是否为true，如果为true则进行相应的后续，退出程序，否则继续执行循环。如果在睡眠状态被打断，那么在异常处理中再执行一次interrupt进行打断标记，这样在下一次的循环对打断标记的检测中则可以正常的处理后续退出程序了</p><p><img src="https://z4a.net/images/2023/03/13/5dbfe670c4234413b9005b241f0e67ba.png"></p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>一般主线程需要等待所有子线程结束之后才会终止运行，守护线程则没有这样的要求，主线程结束，守护线程也就立即结束。设置某个线程为守护线程的方式为 setDaemon</p><h2 id="线程的状态的"><a href="#线程的状态的" class="headerlink" title="线程的状态的"></a>线程的状态的</h2><h3 id="五种"><a href="#五种" class="headerlink" title="五种"></a>五种</h3><p>从操作系统层面来看的话分为以下5种</p><p>初始状态，可运行状态，运行状态，阻塞状态，终止状态</p><p>初始状态：线程已经创建好但还没有和操作系统进行关联</p><p>可运行状态：CPU可以调度执行的状态，但需要竞争</p><p>运行状态：CPU正在执行的状态</p><p>阻塞状态：没有参与CPU的调度竞争，结束阻塞后进入可运行状态</p><p>终止状态：线程结束</p><h3 id="六种"><a href="#六种" class="headerlink" title="六种"></a>六种</h3><p>从Java层面可分为5中</p><p>new，Runnable，TimeWaiting，Waiting，Blocked，Terminated</p><p>new：线程对象已创建但没有运行</p><p>Runnable：可运行状态，包括了操作系统层面的可运行状态和运行状态，以及IO操作的阻塞状态</p><p>Waiting：线程等待状态，无限等待，除非被唤醒再进入Runnable进行CPU调度竞争</p><p>TimeWaiting：线程有限等待，时间一到或被唤醒则进入Runnable状态</p><p>Blocked：阻塞状态，主要只锁竞争阻塞</p><p>Terminated： 线程结束</p><h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>一个代码块内存在多个线程对共享资源的读写操作，称这段代码块为临界区</p><h2 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h2><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><h2 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h2><p>synchronize能够保证线程同步执行某一段代码，保证代码的原子性，其原理就是给一个对象加上锁，只有获取到锁的线程才能执行synchronize代码块中的内容。synchronize遵循一个对象一个锁的原则</p><p>synchronize加在方法的前面实际上是一种简化的写法，默认是给this对象加锁，如果是静态方法则是给类对象加锁</p><h2 id="常见线程安全的类"><a href="#常见线程安全的类" class="headerlink" title="常见线程安全的类"></a>常见线程安全的类</h2><p>String、Integer、Hashtable、StringBuffer、Random、Vector以及java.util.concurrent包下的类</p><p>这些类的单个方法是线程安全的，但是组合起来使用则并非线程安全，比如Hashtable的get和put方法，多个线程同时使用get和put方法依然会导致线程不安全</p><p>String类前面加上了修饰符final是为了防止子类继承从而破坏其线程安全性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于Java的多线程，其实我在很早之前就开始使用了，那时候还在大一，在蓝杰跟着做项目，很单纯的使用，不知道原理。但Java多线程涉及到的知识点很多，有些也比较复杂，值得系统的再学习一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;进程与线</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于点滴</title>
    <link href="https://kallenblue.github.io/2023/01/16/%E7%82%B9%E6%BB%B4/%E5%85%B3%E4%BA%8E%E7%82%B9%E6%BB%B4/"/>
    <id>https://kallenblue.github.io/2023/01/16/%E7%82%B9%E6%BB%B4/%E5%85%B3%E4%BA%8E%E7%82%B9%E6%BB%B4/</id>
    <published>2023-01-16T13:18:51.000Z</published>
    <updated>2023-03-14T09:51:18.341Z</updated>
    
    <content type="html"><![CDATA[<p>又有很长时间没有写博客了，</p><p>之前断写是因为b站的教程基本上都有课程笔记，而且记得比自己写的详细得多，所以感觉自己再写笔记是浪费时间</p><p><img src="https://z4a.net/images/2023/03/13/5f4283f349804408a3cb2e327c5ccc35.png" alt="已经存在电脑上的课程笔记"></p><p>但是，一段时间下来，发现自己在学完知识点后没有及时总结会很快忘记，别人的笔记始终是别人的，只有自己消化了才能真正掌握知识，比如现在让我讲一讲Nginx，光是讲使用我都得翻看笔记才能讲得出来</p><p>所以我觉得课程笔记只能当成文档来看，总结始终得自己来，一点一滴地积累，不管多少，详略都是自己的，面试的时候能够说出来的也是这些点滴。以后这一类文章我会不参照任何资料，按照自己的理解记录一些知识点，当然很可能是错的，不全面的，但绝对是有效果的，值得的。</p><hr><p>23 1.18</p><p>因为记忆衰减和知识深入的原因，之前写的东西有可能会忘记也可能会有补充，所以随时都可能对以往的知识进行复习或补充，补充的形式以(ps)来表示，可以段末另起一段也可以插入补充</p><hr><p>23 1.19</p><p>我发现运动锻炼真的会让人更加的自律</p><p>因为锻炼给人一种很直观的正反馈，运动锻炼之后会出汗，隔一天还可能会肌肉酸胀（我把它看为身体更结实的过程），并且会很直观的觉得自己更健康了。这种正反馈很棒，我觉得这一点可以用到各个方面上。游戏之所以很吸引人就是因为游戏能很快给玩家一个反馈，段位、等级、装备等这些都是反馈的一些表现。学习方面如果能及时的得到反馈那么就能够更加有效的进行学习，所以及时有效的记录自己的学习过程也是一种反馈，应该养成这方面的习惯，也要积极的去寻找事情的反馈，以增强动力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;又有很长时间没有写博客了，&lt;/p&gt;
&lt;p&gt;之前断写是因为b站的教程基本上都有课程笔记，而且记得比自己写的详细得多，所以感觉自己再写笔记是浪费时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://z4a.net/images/2023/03/13/5f4283f349804</summary>
      
    
    
    
    <category term="点滴" scheme="https://kallenblue.github.io/categories/%E7%82%B9%E6%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>B-树和B+树</title>
    <link href="https://kallenblue.github.io/2023/01/16/%E7%82%B9%E6%BB%B4/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/"/>
    <id>https://kallenblue.github.io/2023/01/16/%E7%82%B9%E6%BB%B4/B-%E6%A0%91%E5%92%8CB-%E6%A0%91/</id>
    <published>2023-01-16T13:17:13.000Z</published>
    <updated>2023-03-14T10:19:16.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>B+树作为MySQL中的InooDB存储引擎中的索引相比于其他树结构，在索引方面具有很大的优势</p></blockquote><h2 id="关于B-树"><a href="#关于B-树" class="headerlink" title="关于B-树"></a>关于B-树</h2><p>首先简述一下B-树，B-树就是平衡二叉树的进阶版，一个结点上能保存多个值，且拥有多个子结点，子结点个数为结点值的个数+1，一个结点能够拥有的最多结点数即为B-树的阶</p><h2 id="B-树的优势"><a href="#B-树的优势" class="headerlink" title="B-树的优势"></a>B-树的优势</h2><p>B-树相对于平衡二叉树的优势点就在于，在相同的存储数量和值的情况下，B-树的深度大大降低了，这样能够加快查找速率，因为在树结构中，查找速率和树的深度有关</p><h2 id="B-树的引入"><a href="#B-树的引入" class="headerlink" title="B+树的引入"></a>B+树的引入</h2><p>B+树和B-树的不同点在于非叶子结点不存储具体的内容，只会存储一个键值，用于查找，具体内容则全部存储在叶子结点中，并使用链表的形式将各个结点连接起来</p><p>这样做的原因和计算机的虚拟内存有关，首先，所有的数据都存储在磁盘中，而在使用数据的时候需要从内存中取，这是由磁盘和内存不同的读写速度导致的，磁盘的读写速度远小于内存的读写速度。而操作系统中又采用分页式存储管理，一般缓存都是以页来作为存储单位。要想在相同的存储空间中能够获得更多的数据那么最好的办法就是尽可能多的存储页的指向，也就是一个页指针。B+树正是考虑到了这一点，非叶子结点存储的就相当于指针，叶子结点才存储真正的值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;B+树作为MySQL中的InooDB存储引擎中的索引相比于其他树结构，在索引方面具有很大的优势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于B-树&quot;&gt;&lt;a href=&quot;#关于B-树&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
    <category term="点滴" scheme="https://kallenblue.github.io/tags/%E7%82%B9%E6%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-并发</title>
    <link href="https://kallenblue.github.io/2022/10/27/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91/"/>
    <id>https://kallenblue.github.io/2022/10/27/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%B9%B6%E5%8F%91/</id>
    <published>2022-10-27T07:32:20.000Z</published>
    <updated>2023-03-13T04:11:47.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java线程中的状态"><a href="#java线程中的状态" class="headerlink" title="java线程中的状态"></a>java线程中的状态</h1><p><img src="https://s1.ax1x.com/2023/03/13/ppQmj3Q.png"></p><h2 id="NEW-新建"><a href="#NEW-新建" class="headerlink" title="NEW-新建"></a>NEW-新建</h2><p>线程处于新建状态并没有和CPU中的线程关联起来，仅仅是一个线程对象，只有在使用start方法后才和CPU关联起来</p><h2 id="RUNNABLE-可运行"><a href="#RUNNABLE-可运行" class="headerlink" title="RUNNABLE-可运行"></a>RUNNABLE-可运行</h2><p>开始执行代码内容</p><h2 id="TERMINATED-终结"><a href="#TERMINATED-终结" class="headerlink" title="TERMINATED-终结"></a>TERMINATED-终结</h2><p>代码执行完毕后进入终结状态，相关资源被回收</p><h2 id="BLOCKED-阻塞"><a href="#BLOCKED-阻塞" class="headerlink" title="BLOCKED-阻塞"></a>BLOCKED-阻塞</h2><p>在多线程的情况下，可能会出现多个线程争抢同一把锁的时候，没有竞争到锁的线程会进入阻塞状态，当线程获取到锁时会重新进入可运行状态</p><h2 id="WATING-等待"><a href="#WATING-等待" class="headerlink" title="WATING-等待"></a>WATING-等待</h2><p>某些情况下，线程获取锁后还需要满足一些其他条件才能继续运行，线程获得锁后执行了wait()方法，此时线程进入等待状态，并且释放锁，当其他线程使用notify()方法唤醒等待状态的线程时，等待的线程重新去竞争锁再进入可运行状态</p><h2 id="TIMED-WATING-时限等待"><a href="#TIMED-WATING-时限等待" class="headerlink" title="TIMED_WATING-时限等待"></a>TIMED_WATING-时限等待</h2><p>和等待不同的地方在于，wait(long)方法中加入了时间参数，单位为毫秒，如果计时结束还没有收到其他线程的notify()方法，那么线程也会醒来重新去竞争锁。<br>另外，线程调用sleep(long)函数也会进入时限等待状态，但此时线程只会在计时结束后自动苏醒</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java线程中的状态&quot;&gt;&lt;a href=&quot;#java线程中的状态&quot; class=&quot;headerlink&quot; title=&quot;java线程中的状态&quot;&gt;&lt;/a&gt;java线程中的状态&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java面试-单例模式</title>
    <link href="https://kallenblue.github.io/2022/10/21/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kallenblue.github.io/2022/10/21/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-10-21T05:06:37.000Z</published>
    <updated>2023-03-13T04:12:11.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式的意义"><a href="#单例模式的意义" class="headerlink" title="单例模式的意义"></a>单例模式的意义</h1><ol><li>控制资源的使用，避免对资源的多重占用</li><li>减少内存开销<h1 id="五种实现方式"><a href="#五种实现方式" class="headerlink" title="五种实现方式"></a>五种实现方式</h1><h2 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h2>所谓饿汉即是在类加载初就会创建对象<br>将构造方法私有化，并创建私有的静态final类对象成员，最后给出供外界调用的获取对象的方法<br>下面给出实现的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.review.singleton;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;private Singleton()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="破坏单例的方式"><a href="#破坏单例的方式" class="headerlink" title="破坏单例的方式"></a>破坏单例的方式</h3><h4 id="1-反射创建实例"><a href="#1-反射创建实例" class="headerlink" title="1. 反射创建实例"></a>1. 反射创建实例</h4>通过反射机制，调用单例的私有构造方法创建新的实例对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    reflection(Singleton1.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reflection</span><span class="params">(Class&lt;?&gt; clazz)</span></span><br><span class="line">      <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;反射创建实例:&quot;</span> + constructor.newInstance());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>应对措施<br>在构造方法中判断单例对象是否已经被创建  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;单例不能被重复创建&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;private Singleton()&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-反序列化破坏单例"><a href="#2-反序列化破坏单例" class="headerlink" title="2.反序列化破坏单例"></a>2.反序列化破坏单例</h4>如果单例里面实现了序列化接口，那么就有可能被反序列化破坏单例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializable</span><span class="params">(Object instance)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">  <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">  <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">  oos.writeObject(instance);</span><br><span class="line">  <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray()));</span><br><span class="line">  System.out.println(<span class="string">&quot;反序列化创建实例：&quot;</span>+ois.readObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>应对措施<br>在单例中实现readResolve()方法，返回单例对象，这样在反序列化中获得的对象就会从这个方法里面获取<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Unsafe破坏单例"><a href="#3-Unsafe破坏单例" class="headerlink" title="3.Unsafe破坏单例"></a>3.Unsafe破坏单例</h4>这个目前我不是很熟，只是知道用这个可以破坏单例，并且没有找到应对措施<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unsafe</span><span class="params">(Class&lt;?&gt; clazz)</span></span><br><span class="line">    <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">  Class&lt;Unsafe&gt; unsafeClass = Unsafe.class;</span><br><span class="line">  Constructor&lt;Unsafe&gt; unsafeConstructor = unsafeClass.getDeclaredConstructor();</span><br><span class="line">  unsafeConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> unsafeConstructor.newInstance();</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> unsafe.allocateInstance(clazz);</span><br><span class="line">  System.out.println(<span class="string">&quot;Unsafe 创建实例：&quot;</span>+o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-枚举饿汉式"><a href="#2-枚举饿汉式" class="headerlink" title="2. 枚举饿汉式"></a>2. 枚举饿汉式</h2>枚举类中默认设置构造方法为私有方法，枚举类是一种特殊的类，它可以由如下类表示它内部的实现原理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">  MALE,FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sex</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Sex&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Sex</span><span class="params">(String name, <span class="type">int</span> ordinal)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(name, ordinal);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    MALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;MALE&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    FEMALE = <span class="keyword">new</span> <span class="title class_">Sex</span>(<span class="string">&quot;FEMALE&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    $VALUES = values();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  Sex[] $VALUES;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Sex[] $values()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sex</span>[]&#123;MALE,FEMALE&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values()&#123;</span><br><span class="line">    <span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title function_">valueOf</span><span class="params">(String value)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Enum.valueOf(Sex.class, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>通过定义枚举类可以很方便的实现一个单例，其构造方法默认都是私有方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  Singleton2()&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;private Singleton2()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()+<span class="string">&quot;@&quot;</span>+Integer.toHexString((hashCode()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>枚举类单例也是饿汉式单例，在类加载的时候就会生成对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line">    Singleton2.otherMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(Singleton2.getInstance());</span><br><span class="line">    System.out.println(Singleton2.getInstance());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Singleton2()</span><br><span class="line">otherMethod()</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">com.review.singleton2.Singleton2@29453f44</span><br><span class="line">com.review.singleton2.Singleton2@29453f44</span><br></pre></td></tr></table></figure><h3 id="破坏单例的方式-1"><a href="#破坏单例的方式-1" class="headerlink" title="破坏单例的方式"></a>破坏单例的方式</h3><h4 id="默认已经处理的方式"><a href="#默认已经处理的方式" class="headerlink" title="默认已经处理的方式"></a>默认已经处理的方式</h4></li><li>枚举型单例中，反序列化不能破坏单例。<br>反序列化对枚举类会进行特殊的处理，它会直接返回单例的实例对象</li><li>使用反射破坏单例在枚举类中也是不允许的，这在枚举类中已经处理了<h4 id="Unsafe破坏单例"><a href="#Unsafe破坏单例" class="headerlink" title="Unsafe破坏单例"></a>Unsafe破坏单例</h4></li><li>unsafe依然可以破坏枚举类的单例<h2 id="3-懒汉式单例"><a href="#3-懒汉式单例" class="headerlink" title="3. 懒汉式单例"></a>3. 懒汉式单例</h2>懒汉式的实现很简单，只需要将单例成员变量的初始赋值设置为null，然后在第一次获取的时候getInstance()中创建即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;private Singleton()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">      INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;otherMethod&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试结果如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException, ClassNotFoundException &#123;</span><br><span class="line">    Singleton3.otherMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(Singleton3.getInstance());</span><br><span class="line">    System.out.println(Singleton3.getInstance());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">otherMethod</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">private Singleton()</span><br><span class="line">com.review.singleton3.Singleton3@29453f44</span><br><span class="line">com.review.singleton3.Singleton3@29453f44</span><br></pre></td></tr></table></figure>可以看到，在调用类方法也就是类加载的时候并没有创建单例，只有在获取单例对象的时候才创建单例<h3 id="懒汉模式下的线程安全问题"><a href="#懒汉模式下的线程安全问题" class="headerlink" title="懒汉模式下的线程安全问题"></a>懒汉模式下的线程安全问题</h3>当单例未创建时，有多个线程同时访问getInstance()方法，有可能会出现多个线程调用构造方法的情况，从而破坏单例，解决方法也很简单，在getInstance()方法上加上同步的关键字synchronized即可，即在此方法上加锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但实际上这样的实现方法效率比较低，因为线程保护只需要在第一次调用getInstance()的时候使用，后续运行中，synchronized只会影响程序的性能，没有实质性作用<h2 id="4-DCL懒汉方式"><a href="#4-DCL懒汉方式" class="headerlink" title="4. DCL懒汉方式"></a>4. DCL懒汉方式</h2>DCL(Double Check Lock)双重检查锁定式懒汉单例，在上一种单例方法中，频繁且无用的同步操作会导致程序性能下降，DCL很好的解决了这个问题，代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;private Singleton()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton4</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton4.class)&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">          INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;otherMethod&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当多个线程同时第一次调用getInstance()方法时，会进入第一个判断里，然后其中一个线程拿到锁，进入同步代码块，完成对象创建，释放锁。之后一起进入第一次判断的一个线程也进入同步代码块，但此时对象已经创建，所以不会再进行第二次创建，保证了单例的实现<h3 id="关于volatile字段"><a href="#关于volatile字段" class="headerlink" title="关于volatile字段"></a>关于volatile字段</h3>volatile字段主要是保证成员变量在构造时的”可见性”和”有序性”，在这里主要用到”有序性”,这里需要用汇编的知识来解释，所以需要反编译这个类，查看汇编代码<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c -v -p Singleton4.class</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br></pre></td></tr></table></figure>这行代码对应的汇编指令如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">17: new           #6                  // class com/review/singleton4/Singleton4</span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial #7                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">24: putstatic     #5                  // Field INSTANCE:Lcom/review/singleton4/Singleton4;</span><br></pre></td></tr></table></figure></li><li>17:分配对象需要的内存</li><li>21:对成员变量的初始化-&gt;执行构造方法</li><li>24:给静态变量赋值，这里就是给INSTANCE变量赋值<br>在执行上述汇编的过程中CPU会对我们的汇编指令进行优化，调整一些汇编指令的执行顺序，比如21和24就有可能被CPU调整执行顺序，因为两者没有没有因果关系，谁先执行都不重要<br>根据以上分析，那么就可能出现这样的情况<br><img src="https://s1.ax1x.com/2023/03/13/ppQmvcj.png"><br>蓝色线程在执行**INSTANCE = new Singleton4();**代码的时候，红色线程在进行INSTANCE空值判断，如果CPU将汇编指令的顺序调动，先执行静态变量赋值指令也就是24，那么红色线程就会在空值判断这里判断INSTANCE不为空，并且提前返回INSTANCE，而从汇编代码中可以看到构造方法还未执行，红色线程返回的对象必然是缺省的<br>加上volatile字段后，汇编指令就会按照顺序执行，不会被CPU调换执行顺序，从而避免这个问题<h2 id="5-内部类懒汉式"><a href="#5-内部类懒汉式" class="headerlink" title="5. 内部类懒汉式"></a>5. 内部类懒汉式</h2>之前的懒汉式单例都不可避免的遇到多线程的问题，但内部类懒汉模式较好的规避了这个问题，内部类本身就符合懒惰加载的特征，并且内部类可以访问外部类的私有变量，所以，通过在内部类中创建单例对象就可以实现懒汉式单例模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;private singleton()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式在jdk中的体现"><a href="#单例模式在jdk中的体现" class="headerlink" title="单例模式在jdk中的体现"></a>单例模式在jdk中的体现</h1><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2>截取了部分代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看出Runtime是饿汉式的单例模式<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2>截取System类中的Console对象的创建(Console是一个控制台的抽象类)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Console</span> <span class="variable">cons</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Console <span class="title function_">console</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (cons == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (System.class) &#123;</span><br><span class="line">                 cons = sun.misc.SharedSecrets.getJavaIOAccess().console();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> cons;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>cons = sun.misc.SharedSecrets.getJavaIOAccess().console();在这个方法链中也有一个判断当前cons是否为空的语句<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.SharedSecrets.setJavaIOAccess(<span class="keyword">new</span> <span class="title class_">sun</span>.misc.JavaIOAccess() &#123;</span><br><span class="line">    <span class="keyword">public</span> Console <span class="title function_">console</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (istty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cons == <span class="literal">null</span>)</span><br><span class="line">                cons = <span class="keyword">new</span> <span class="title class_">Console</span>();</span><br><span class="line">            <span class="keyword">return</span> cons;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Charset <span class="title function_">charset</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// This method is called in sun.security.util.Password,</span></span><br><span class="line">        <span class="comment">// cons already exists when this method is called</span></span><br><span class="line">        <span class="keyword">return</span> cons.cs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>可以看出是一个双检索懒汉式的单例模型<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2>集合中有大量的空集合的需求，而这些空集合对象就是用的单例模式创建的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnmodifiableNavigableSet</span>&lt;E&gt;</span><br><span class="line">                            <span class="keyword">extends</span> <span class="title class_">UnmodifiableSortedSet</span>&lt;E&gt;</span><br><span class="line">                            <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Serializable &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmptyNavigableSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">UnmodifiableNavigableSet</span>&lt;E&gt;</span><br><span class="line">          <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6291252904449939134L</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">public</span> <span class="title function_">EmptyNavigableSet</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;E&gt;());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span>        &#123; <span class="keyword">return</span> EMPTY_NAVIGABLE_SET; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NavigableSet&lt;?&gt; EMPTY_NAVIGABLE_SET =</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">EmptyNavigableSet</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; NavigableSet&lt;E&gt; <span class="title function_">emptyNavigableSet</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (NavigableSet&lt;E&gt;) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看出EmptyNavigableSet是采用静态内部类的单例模式创建的空对象，其中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span>        &#123; <span class="keyword">return</span> EMPTY_NAVIGABLE_SET; &#125;</span><br></pre></td></tr></table></figure>还考虑了反序列化破坏单例的问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式的意义&quot;&gt;&lt;a href=&quot;#单例模式的意义&quot; class=&quot;headerlink&quot; title=&quot;单例模式的意义&quot;&gt;&lt;/a&gt;单例模式的意义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;控制资源的使用，避免对资源的多重占用&lt;/li&gt;
&lt;li&gt;减少内存开销&lt;h1 id=&quot;五种</summary>
      
    
    
    
    <category term="Java面试" scheme="https://kallenblue.github.io/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java面试-容器</title>
    <link href="https://kallenblue.github.io/2022/10/20/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%AE%B9%E5%99%A8/"/>
    <id>https://kallenblue.github.io/2022/10/20/Java%E9%9D%A2%E8%AF%95/Java%E9%9D%A2%E8%AF%95-%E5%AE%B9%E5%99%A8/</id>
    <published>2022-10-20T01:08:12.000Z</published>
    <updated>2023-03-10T11:48:07.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h2><ul><li>当ArrayList使用无参构造时，容器大小为0<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>如果传入一个集合，那么则以集合的大小为容器的初始容量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h2><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3></li></ul><ul><li><p>如果容器的初始大小为0，那么第一次扩容大小为10</p></li><li><p>之后如果元素个数超出容器大小，每次扩容为原容器的1.5倍</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3></li><li><p>选择(默认扩容方式扩容后的大小)与(原来容器的大小加上addAll()中集合参数中的大小)这两者中最大的那个为扩容标准</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">newCapacity = minCapacity;</span><br></pre></td></tr></table></figure><h2 id="FailFast"><a href="#FailFast" class="headerlink" title="FailFast"></a>FailFast</h2><p>在迭代遍历的时候，如果发现容器被修改，则立刻抛出异常，ArrayList是典型代表<br>ArrayList在初始化迭代器时会记录当前容器的修改次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br></pre></td></tr></table></figure><p>在后续迭代的过程中会检查这个修改次数有没有发生变化，如果发生了变化则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FailSafe"><a href="#FailSafe" class="headerlink" title="FailSafe"></a>FailSafe</h2><p>在迭代遍历的时候，如果发现容器被修改，应当有一定措施，例如牺牲一致性来让整个遍历完成，CopyOnWriteArrayList是典型代表<br>CopyOnWriteArrayList在初始化迭代器时会复制一份当前容器的数组，遍历的数组和容器的数组独立起来，从而不会相互影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ArrayList和LinkedList比较"><a href="#ArrayList和LinkedList比较" class="headerlink" title="ArrayList和LinkedList比较"></a>ArrayList和LinkedList比较</h1></li><li><p>ArrayList</p><ul><li>基于数组，需要连续内存</li><li>随机访问快（根据下标访问）</li><li>尾部的插入和删除性能良好，但其他部分插入、删除都会移动数据，性能差</li><li>可以利用cpu缓存，局部性原理</li></ul></li><li><p>LinkedList</p><ul><li>基于双向链表，无需连续内存</li><li>随机访问慢（要沿着链表遍历）</li><li>头尾插入、删除性能高（删除中间的元素需要一个查询定位，效率低）</li><li>占用内存多</li></ul></li></ul><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><ul><li>1.7：数组+链表</li><li>1.8以上：数组+（链表|红黑树）</li></ul><h2 id="HashMap中的红黑树"><a href="#HashMap中的红黑树" class="headerlink" title="HashMap中的红黑树"></a>HashMap中的红黑树</h2><ul><li><ol><li>红黑树是用来避免DoS攻击，即用户刻意存储大量拥有相同hash值的元素，这种情况下导致链表很长，导致性能下降。但是一般情况下不会出现这种情况，所以树化应该是偶然情况</li></ol><ul><li><ol><li>hash表的查找、更新的时间复杂度是O(1)，而红黑树的查找，更新的时间复杂度是O(log<del>2</del>n),TreeNode占用空间也比普通Node的空间大，所以，如非必要，尽量使用链表</li></ol></li><li><ol start="2"><li>hash值如果足够随机，则再hash表内按泊松分布，在负载因子为0.75(达到3/4就扩容)的情况下，长度超过8的链表出现概率基本为0，选择树化阈值为8是为了让树化的几率足够小</li></ol></li></ul></li><li><ol start="2"><li>HashMap树化的两个条件：链表长度超过树化阈值；数组容量&gt;=64</li></ol></li><li><ol start="3"><li>退化情况1：在扩容时，一些元素的桶值会发生变化，会使树发生拆分，如果拆分后树的元素个数&lt;=6则会退化成链表</li></ol></li><li><ol start="4"><li>退化情况2：删除树节点时，如果root、root.left、root.right、root.left.left中有一个为null，也会退化成链表<h2 id="HashMap中的哈希"><a href="#HashMap中的哈希" class="headerlink" title="HashMap中的哈希"></a>HashMap中的哈希</h2></li></ol></li><li><ol><li>索引：计算对象的hashcode()，再进行调用HashMap的hash()方法进行二次哈希，最后&amp;(capacity-1)(即取模)得到索引<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>二次hash()是为了综合高位数据(将int数据的高16位与低16位异或)，让哈希分布更为均匀</li></ol></li><li><ol start="3"><li>计算索引时，如果HashMap的容量是2的n次幂，则可以使用位与运算代替取模&amp;(capacity-1)，效率更高;扩容时hash&amp;oldCap == 0的元素留在原来位置，否则新位置 = 旧位置 + oldCap(旧容量)</li></ol></li><li><ol start="4"><li>1，2，3都是为了配合容量为2的n次幂的hashmap的优化手段。实际上容量为质数会使元素的分布更均匀，但设计者为了综合的性能，最终还是选择了使用2的n次幂作为容量</li></ol></li></ul><h2 id="put新增-修改元素过程"><a href="#put新增-修改元素过程" class="headerlink" title="put新增/修改元素过程"></a>put新增/修改元素过程</h2><ul><li><ol><li>HashMap是懒惰创建数组的，首次使用才创建数组</li></ol></li><li><ol start="2"><li>计算索引(桶下标)</li></ol></li><li><ol start="3"><li>如果桶下标还没人占用，创建Node占位返回</li></ol></li><li><ol start="4"><li>如果桶下标已经有人占用</li></ol><ul><li><ol><li>已经是TreeNode走红黑树的添加或更新逻辑</li></ol></li><li><ol start="2"><li>普通的Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li></ol></li></ul></li><li><ol start="5"><li>返回前检查容量是否超过阈值，一旦超过则进行扩容</li></ol></li><li><ol start="6"><li>1.7和1.8以上的不同点</li></ol><ul><li><ol><li>链表插入节点时，1.7是头插法，1.8是尾插法</li></ol></li><li><ol start="2"><li>1.7大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容</li></ol></li><li><ol start="3"><li>1.8在扩容计算Node索引时会进行优化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩容时hash&amp;oldCap == 0的元素留在原来位置，否则新位置 = 旧位置 + oldCap</span><br></pre></td></tr></table></figure><h2 id="负载因子设置为0-75f的原因"><a href="#负载因子设置为0-75f的原因" class="headerlink" title="负载因子设置为0.75f的原因"></a>负载因子设置为0.75f的原因</h2></li></ol></li></ul></li><li><ol><li>在空间占用与查询时间之间取得较好的权衡</li></ol></li><li><ol start="2"><li>大于这个值，空间节省了，但链表就会比较长，影响性能</li></ol></li><li><ol start="3"><li>小于这个值，冲突减少了，但扩容会更频繁，空间占用多</li></ol></li></ul><h2 id="多线程下出现的问题"><a href="#多线程下出现的问题" class="headerlink" title="多线程下出现的问题"></a>多线程下出现的问题</h2><ul><li><ol><li>在1.7中并发扩容可能会出现死链</li></ol></li><li><ol start="2"><li>如果同时插入两个桶下标相同的两个元素，则会发生数据丢失的问题<h2 id="HashMap的key"><a href="#HashMap的key" class="headerlink" title="HashMap的key"></a>HashMap的key</h2></li></ol></li><li><ol><li>HashMap的key可以为null，但Map的其他实现则不然</li></ol></li><li><ol start="2"><li>作为key的对象，必须实现hashCode和equals，并且key的内容不能修改(不可改变)</li></ol></li></ul><h2 id="String对象的hashCode"><a href="#String对象的hashCode" class="headerlink" title="String对象的hashCode()"></a>String对象的hashCode()</h2><p>hashCode()设计的目标是为了达到较为均匀的散列效果，每个字符串的hashCode需要足够独特</p><ul><li><ol><li>字符串中的每一个字符都可以表现为一个数字，称为S<del>i</del>,其中i的范围是0~n-1</li></ol></li><li><ol start="2"><li>散列公式为：S<del>0</del> * 31^n-1^+S<del>1</del> * 31^n-1^+…+s<del>i</del> * 31^n-1-1^+…+S<del>n-1</del> * 31^0^</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h1&gt;&lt;h2 id=&quot;创建规则&quot;&gt;&lt;a href=&quot;#创建规则&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java面试" scheme="https://kallenblue.github.io/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Pytorch-Tensor基础</title>
    <link href="https://kallenblue.github.io/2022/10/19/Pytorch/Pytorch-Tensor%E5%9F%BA%E7%A1%80/"/>
    <id>https://kallenblue.github.io/2022/10/19/Pytorch/Pytorch-Tensor%E5%9F%BA%E7%A1%80/</id>
    <published>2022-10-19T12:17:55.000Z</published>
    <updated>2023-03-10T11:48:07.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensor中的shape和size"><a href="#tensor中的shape和size" class="headerlink" title="tensor中的shape和size()"></a>tensor中的shape和size()</h1><p>反映了tensor的格式，二维的tensor的shape/size()对应矩阵中的行和列的大小，这样理解即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 创建0维的tensor-&gt;标量</span></span><br><span class="line">a = torch.tensor(<span class="number">2.5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a.size())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># tensor(2.5000)</span></span><br><span class="line"><span class="comment"># torch.Size([])</span></span><br><span class="line"><span class="comment"># torch.Size([])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个tensor</span></span><br><span class="line">a = torch.tensor([<span class="number">2.2</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a.size())</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([2.2000, 3.5000])</span></span><br><span class="line"><span class="comment"># torch.Size([2])</span></span><br><span class="line"><span class="comment"># torch.Size([2])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个二维度的tensor</span></span><br><span class="line">a = torch.FloatTensor(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a.size())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[3.2605e-12, 7.4086e+28, 7.3697e+28],</span></span><br><span class="line"><span class="comment">#         [1.0947e+27, 1.7785e+25, 1.2122e+04],</span></span><br><span class="line"><span class="comment">#         [7.1846e+22, 6.9983e+28, 2.9593e+21]])</span></span><br><span class="line"><span class="comment"># torch.Size([3, 3])</span></span><br><span class="line"><span class="comment"># torch.Size([3, 3])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="不同维度的tensor"><a href="#不同维度的tensor" class="headerlink" title="不同维度的tensor"></a>不同维度的tensor</h1><h2 id="0，1维"><a href="#0，1维" class="headerlink" title="0，1维"></a>0，1维</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0维</span></span><br><span class="line">a = torch.tensor(<span class="number">2.2</span>)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="comment"># 返回维度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(a.shape))</span><br><span class="line"><span class="built_in">print</span>(a.size())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># torch.Size([])</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># torch.Size([])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1维</span></span><br><span class="line">a = torch.tensor([<span class="number">1.1</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([1.1000])</span></span><br><span class="line"></span><br><span class="line">a = torch.tensor([<span class="number">1.1</span>, <span class="number">2.2</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([1.1000, 2.2000])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机创建一个一维，长度为1的tensor</span></span><br><span class="line">a = torch.FloatTensor(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([1.4013e-45])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机创建一个一维，长度为2的tensor</span></span><br><span class="line">a = torch.FloatTensor(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([0.0000, 1.8750])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个一维的，长度为2且元素值为1的向量</span></span><br><span class="line">data = np.ones(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 根据向量创建tensor</span></span><br><span class="line">a = torch.from_numpy(data)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [1. 1.]</span></span><br><span class="line"><span class="comment"># tensor([1., 1.], dtype=torch.float64)</span></span><br></pre></td></tr></table></figure><h2 id="二、三维"><a href="#二、三维" class="headerlink" title="二、三维"></a>二、三维</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 根据正态分布随机生成tensor</span></span><br><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a.size(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(a.size(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.shape[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[-0.2871, -0.2379,  0.0436],</span></span><br><span class="line"><span class="comment">#         [ 1.5324,  0.7144,  0.0508]])</span></span><br><span class="line"><span class="comment"># torch.Size([2, 3])</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据正态分布随机生成</span></span><br><span class="line">a = torch.rand(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a.shape))</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[[0.3967, 0.1736, 0.6457],</span></span><br><span class="line"><span class="comment">#          [0.8819, 0.7055, 0.3417]],</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         [[0.6029, 0.6032, 0.4393],</span></span><br><span class="line"><span class="comment">#          [0.8388, 0.0709, 0.0857]]])</span></span><br><span class="line"><span class="comment"># torch.Size([2, 2, 3])</span></span><br><span class="line"><span class="comment"># tensor([[0.3967, 0.1736, 0.6457],</span></span><br><span class="line"><span class="comment">#         [0.8819, 0.7055, 0.3417]])</span></span><br><span class="line"><span class="comment"># [2, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="四维及其他"><a href="#四维及其他" class="headerlink" title="四维及其他"></a>四维及其他</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">a = torch.rand(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="comment"># 返回tensor元素的个数：2*3*4*2</span></span><br><span class="line"><span class="built_in">print</span>(a.numel())</span><br><span class="line"><span class="comment"># 返回tensor元素的维度</span></span><br><span class="line"><span class="built_in">print</span>(a.dim())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[[[0.5599, 0.2723],</span></span><br><span class="line"><span class="comment">#           [0.0488, 0.2327],</span></span><br><span class="line"><span class="comment">#           [0.2166, 0.8122],</span></span><br><span class="line"><span class="comment">#           [0.0877, 0.0184]],</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#          [[0.4803, 0.9102],</span></span><br><span class="line"><span class="comment">#           [0.3802, 0.5224],</span></span><br><span class="line"><span class="comment">#           [0.1912, 0.8837],</span></span><br><span class="line"><span class="comment">#           [0.9155, 0.5591]],</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#          [[0.3846, 0.7604],</span></span><br><span class="line"><span class="comment">#           [0.7920, 0.7762],</span></span><br><span class="line"><span class="comment">#           [0.7335, 0.5712],</span></span><br><span class="line"><span class="comment">#           [0.2319, 0.5643]]],</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#         [[[0.3215, 0.3339],</span></span><br><span class="line"><span class="comment">#           [0.4448, 0.2315],</span></span><br><span class="line"><span class="comment">#           [0.7863, 0.2281],</span></span><br><span class="line"><span class="comment">#           [0.1447, 0.7601]],</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#          [[0.9106, 0.8218],</span></span><br><span class="line"><span class="comment">#           [0.6886, 0.8535],</span></span><br><span class="line"><span class="comment">#           [0.9112, 0.8106],</span></span><br><span class="line"><span class="comment">#           [0.2282, 0.9450]],</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#          [[0.5409, 0.3910],</span></span><br><span class="line"><span class="comment">#           [0.6941, 0.9943],</span></span><br><span class="line"><span class="comment">#           [0.6982, 0.7778],</span></span><br><span class="line"><span class="comment">#           [0.7190, 0.3657]]]])</span></span><br><span class="line"><span class="comment"># torch.Size([2, 3, 4, 2])</span></span><br><span class="line"><span class="comment"># 48</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h1 id="创建tensor"><a href="#创建tensor" class="headerlink" title="创建tensor"></a>创建tensor</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 创建一个一维，长度为2的array，再通过torch创建tensor</span></span><br><span class="line">array = np.array([<span class="number">2.1</span>, <span class="number">3.3</span>])</span><br><span class="line">a = torch.from_numpy(array)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([2.1000, 3.3000], dtype=torch.float64)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个二维，长度分别为2和3的array，再通过torch创建tensor</span></span><br><span class="line">array = np.ones([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">a = torch.from_numpy(array)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[1., 1., 1.],</span></span><br><span class="line"><span class="comment">#         [1., 1., 1.]], dtype=torch.float64)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># torch通过list直接创建tensor</span></span><br><span class="line">a = torch.tensor([<span class="number">2.</span>, <span class="number">3.2</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = torch.tensor([[<span class="number">2.</span>, <span class="number">3.2</span>], [<span class="number">1.</span>, <span class="number">2.6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([2.0000, 3.2000])</span></span><br><span class="line"><span class="comment"># tensor([[2.0000, 3.2000],</span></span><br><span class="line"><span class="comment">#         [1.0000, 2.6000]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tensor()方法根据参数个数创建对应维度的tensor，每个维度的长度为参数的大小</span></span><br><span class="line">a = torch.Tensor(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[0., 0., 0.],</span></span><br><span class="line"><span class="comment">#         [0., 0., 0.],</span></span><br><span class="line"><span class="comment">#         [0., 0., 0.]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 未初始化的tensor</span></span><br><span class="line">a = torch.IntTensor(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = torch.FloatTensor(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[1, 0, 1],</span></span><br><span class="line"><span class="comment">#         [0, 1, 0]], dtype=torch.int32)</span></span><br><span class="line"><span class="comment"># tensor([[-1.5556e-18,  5.3249e-43,  0.0000e+00],</span></span><br><span class="line"><span class="comment">#         [ 0.0000e+00,  0.0000e+00,  0.0000e+00]])</span></span><br></pre></td></tr></table></figure><p>tensor创建默认是FloatTensor类型，可以通过下面的方式修改默认</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.set_default_tensor_type(torch.DoubleTensor)</span><br></pre></td></tr></table></figure><h2 id="rand"><a href="#rand" class="headerlink" title="rand*"></a>rand*</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机创建一个值在(0,1)的3*3二维tensor</span></span><br><span class="line">a = torch.rand(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 传入一个tensor并执行rand函数创建新的tensor</span></span><br><span class="line">a = torch.rand_like(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 创建一个值在[1, 10)的3*3二维tensor</span></span><br><span class="line">a = torch.randint(<span class="number">1</span>, <span class="number">10</span>, [<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[0.2667, 0.3021, 0.1402],</span></span><br><span class="line"><span class="comment">#         [0.9188, 0.2889, 0.4163],</span></span><br><span class="line"><span class="comment">#         [0.2108, 0.9262, 0.5140]])</span></span><br><span class="line"><span class="comment"># tensor([[0.6878, 0.0178, 0.3735],</span></span><br><span class="line"><span class="comment">#         [0.8983, 0.6910, 0.3853],</span></span><br><span class="line"><span class="comment">#         [0.1530, 0.5895, 0.7096]])</span></span><br><span class="line"><span class="comment"># tensor([[2, 5, 6],</span></span><br><span class="line"><span class="comment">#         [6, 9, 8],</span></span><br><span class="line"><span class="comment">#         [8, 6, 7]])</span></span><br></pre></td></tr></table></figure><h2 id="full"><a href="#full" class="headerlink" title="full"></a>full</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># full,创建一个2*3，且元素值皆为7的tensor</span></span><br><span class="line">a = torch.full([<span class="number">2</span>, <span class="number">3</span>], <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 创建一个元素为7的标量</span></span><br><span class="line">a = torch.full([], <span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([[7, 7, 7],</span></span><br><span class="line"><span class="comment">#         [7, 7, 7]])</span></span><br><span class="line"><span class="comment"># tensor(7)</span></span><br></pre></td></tr></table></figure><h2 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个差值为1的等差一维tensor</span></span><br><span class="line">a = torch.arange(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 创建一个差值为2的等差一维tensor</span></span><br><span class="line">a = torch.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"><span class="comment"># tensor([0, 2, 4, 6, 8])</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tensor中的shape和size&quot;&gt;&lt;a href=&quot;#tensor中的shape和size&quot; class=&quot;headerlink&quot; title=&quot;tensor中的shape和size()&quot;&gt;&lt;/a&gt;tensor中的shape和size()&lt;/h1&gt;&lt;p&gt;反映</summary>
      
    
    
    
    <category term="Pytorch" scheme="https://kallenblue.github.io/categories/Pytorch/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx基础</title>
    <link href="https://kallenblue.github.io/2022/10/17/Nginx/Nginx%E5%9F%BA%E7%A1%80/"/>
    <id>https://kallenblue.github.io/2022/10/17/Nginx/Nginx%E5%9F%BA%E7%A1%80/</id>
    <published>2022-10-17T08:04:12.000Z</published>
    <updated>2023-03-13T15:56:32.242Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习的过程中发现有现成的笔记，所以就不再自己写了</p></blockquote><h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>Nginx（“engine x”）一个具有高性能的【HTTP】和【反向代理】的【WEB服务器】，同时也是一个【POP3/SMTP/IMAP代理服务器】，是由伊戈尔·赛索耶夫(俄罗斯人)使用C语言编写的，Nginx的第一个版本是2004年10月4号发布的0.1.0版本。另外值得一提的是伊戈尔·赛索耶夫将Nginx的源码进行了开源，这也为Nginx的发展提供了良好的保障。<br><img src="https://s1.ax1x.com/2023/03/13/ppQnSun.png" alt="在这里插入图片描述"></p><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ol><li>WEB服务器：</li></ol><p>WEB服务器也叫网页服务器，英文名叫Web Server，主要功能是为用户提供网上信息浏览服务。</p><ol start="2"><li>HTTP:</li></ol><p>HTTP是超文本传输协议的缩写，是用于从WEB服务器传输超文本到本地浏览器的传输协议，也是互联网上应用最为广泛的一种网络协议。HTTP是一个客户端和服务器端请求和应答的标准，客户端是终端用户，服务端是网站，通过使用Web浏览器、网络爬虫或者其他工具，客户端发起一个到服务器上指定端口的HTTP请求。</p><ol start="3"><li>POP3/SMTP/IMAP：</li></ol><p>POP3(Post Offic Protocol 3)邮局协议的第三个版本，</p><p>SMTP(Simple Mail Transfer Protocol)简单邮件传输协议，</p><p>IMAP(Internet Mail Access Protocol)交互式邮件存取协议，</p><p>通过上述名词的解释，我们可以了解到Nginx也可以作为电子邮件代理服务器。</p><ol start="4"><li>反向代理</li></ol><p>正向代理</p><p><img src="https://s1.ax1x.com/2023/03/13/ppQnpBq.png" alt="请添加图片描述"></p><p>反向代理</p><p><img src="https://s1.ax1x.com/2023/03/13/ppQnPEV.png" alt="请添加图片描述"></p><h3 id="常见服务器对比"><a href="#常见服务器对比" class="headerlink" title="常见服务器对比"></a>常见服务器对比</h3><p>在介绍这一节内容之前，我们先来认识一家公司叫Netcraft。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Netcraft公司于1994年底在英国成立，多年来一直致力于互联网市场以及在线安全方面的咨询服务，其中在国际上最具影响力的当属其针对网站服务器、SSL市场所做的客观严谨的分析研究，公司官网每月公布的调研数据（Web Server Survey）已成为当今人们了解全球网站数量以及服务器市场分额情况的主要参考依据，时常被诸如华尔街杂志，英国BBC，Slashdot等媒体报道或引用。</span><br></pre></td></tr></table></figure><p>我们先来看一组数据，我们先打开Nginx的官方网站  <a href="http://nginx.org/">http://nginx.org/</a>,找到Netcraft公司公布的数据，对当前主流服务器产品进行介绍。</p><p><img src="https://s1.ax1x.com/2023/03/13/ppQniNT.png" alt="在这里插入图片描述"></p><p>上面这张图展示了2019年全球主流Web服务器的市场情况，其中有Apache、Microsoft-IIS、google Servers、Nginx、Tomcat等，而我们在了解新事物的时候，往往习惯通过类比来帮助自己理解事物的概貌。所以下面我们把几种常见的服务器来给大家简单介绍下：</p><h4 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h4><pre><code>全称(Internet Information Services)即互联网信息服务，是由微软公司提供的基于windows系统的互联网基本服务。windows作为服务器在稳定性与其他一些性能上都不如类UNIX操作系统，因此在需要高性能Web服务器的场合下，IIS可能就会被&quot;冷落&quot;.</code></pre><h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><pre><code>Tomcat是一个运行Servlet和JSP的Web应用软件，Tomcat技术先进、性能稳定而且开放源代码，因此深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。但是Tomcat天生是一个重量级的Web服务器，对静态文件和高并发的处理比较弱。</code></pre><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><pre><code>Apache的发展时期很长，同时也有过一段辉煌的业绩。从上图可以看出大概在2014年以前都是市场份额第一的服务器。Apache有很多优点，如稳定、开源、跨平台等。但是它出现的时间太久了，在它兴起的年代，互联网的产业规模远远不如今天，所以它被设计成一个重量级的、不支持高并发的Web服务器。在Apache服务器上，如果有数以万计的并发HTTP请求同时访问，就会导致服务器上消耗大量能存，操作系统内核对成百上千的Apache进程做进程间切换也会消耗大量的CUP资源，并导致HTTP请求的平均响应速度降低，这些都决定了Apache不可能成为高性能的Web服务器。这也促使了Lighttpd和Nginx的出现。</code></pre><h4 id="Lighttpd"><a href="#Lighttpd" class="headerlink" title="Lighttpd"></a>Lighttpd</h4><pre><code>Lighttpd是德国的一个开源的Web服务器软件，它和Nginx一样，都是轻量级、高性能的Web服务器，欧美的业界开发者比较钟爱Lighttpd,而国内的公司更多的青睐Nginx，同时网上Nginx的资源要更丰富些。</code></pre><h4 id="其他的服务器"><a href="#其他的服务器" class="headerlink" title="其他的服务器"></a>其他的服务器</h4><p>Google Servers，Weblogic, Webshpere(IBM)…</p><p>经过各个服务器的对比，种种迹象都表明，Nginx将以性能为王。这也是我们为什么选择Nginx的理由。</p><h4 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h4><h5 id="1-速度更快、并发更高"><a href="#1-速度更快、并发更高" class="headerlink" title="(1)速度更快、并发更高"></a>(1)速度更快、并发更高</h5><p>单次请求或者高并发请求的环境下，Nginx都会比其他Web服务器响应的速度更快。一方面在正常情况下，单次请求会得到更快的响应，另一方面，在高峰期(如有数以万计的并发请求)，Nginx比其他Web服务器更快的响应请求。Nginx之所以有这么高的并发处理能力和这么好的性能原因在于Nginx采用了多进程和I/O多路复用(epoll)的底层实现。</p><h5 id="2-配置简单，扩展性强"><a href="#2-配置简单，扩展性强" class="headerlink" title="(2)配置简单，扩展性强"></a>(2)配置简单，扩展性强</h5><p>Nginx的设计极具扩展性，它本身就是由很多模块组成，这些模块的使用可以通过配置文件的配置来添加。这些模块有官方提供的也有第三方提供的模块，如果需要完全可以开发服务自己业务特性的定制模块。</p><h5 id="3-高可靠性"><a href="#3-高可靠性" class="headerlink" title="(3)高可靠性"></a>(3)高可靠性</h5><p>Nginx采用的是多进程模式运行，其中有一个master主进程和N多个worker进程，worker进程的数量我们可以手动设置，每个worker进程之间都是相互独立提供服务，并且master主进程可以在某一个worker进程出错时，快速去”拉起”新的worker进程提供服务。</p><h5 id="4-热部署"><a href="#4-热部署" class="headerlink" title="(4)热部署"></a>(4)热部署</h5><p>现在互联网项目都要求以7*24小时进行服务的提供，针对于这一要求，Nginx也提供了热部署功能，即可以在Nginx不停止的情况下，对Nginx进行文件升级、更新配置和更换日志文件等功能。</p><h5 id="5-成本低、BSD许可证"><a href="#5-成本低、BSD许可证" class="headerlink" title="(5)成本低、BSD许可证"></a>(5)成本低、BSD许可证</h5><p>BSD是一个开源的许可证，世界上的开源许可证有很多，现在比较流行的有六种分别是GPL、BSD、MIT、Mozilla、Apache、LGPL。这六种的区别是什么，我们可以通过下面一张图来解释下：</p><p><img src="https://s1.ax1x.com/2023/03/13/ppQnF4U.png" alt="在这里插入图片描述"></p><p>Nginx本身是开源的，我们不仅可以免费的将Nginx应用在商业领域，而且还可以在项目中直接修改Nginx的源码来定制自己的特殊要求。这些点也都是Nginx为什么能吸引无数开发者继续为Nginx来贡献自己的智慧和青春。OpenRestry [Nginx+Lua]   Tengine[淘宝]</p><h3 id="Nginx的功能特性及常用功能"><a href="#Nginx的功能特性及常用功能" class="headerlink" title="Nginx的功能特性及常用功能"></a>Nginx的功能特性及常用功能</h3><p>Nginx提供的基本功能服务从大体上归纳为”基本HTTP服务”、“高级HTTP服务”和”邮件服务”等三大类。</p><h4 id="基本HTTP服务"><a href="#基本HTTP服务" class="headerlink" title="基本HTTP服务"></a>基本HTTP服务</h4><p>Nginx可以提供基本HTTP服务，可以作为HTTP代理服务器和反向代理服务器，支持通过缓存加速访问，可以完成简单的负载均衡和容错，支持包过滤功能，支持SSL等。</p><ul><li>处理静态文件、处理索引文件以及支持自动索引；</li><li>提供反向代理服务器，并可以使用缓存加上反向代理，同时完成负载均衡和容错；</li><li>提供对FastCGI、memcached等服务的缓存机制，，同时完成负载均衡和容错；</li><li>使用Nginx的模块化特性提供过滤器功能。Nginx基本过滤器包括gzip压缩、ranges支持、chunked响应、XSLT、SSI以及图像缩放等。其中针对包含多个SSI的页面，经由FastCGI或反向代理，SSI过滤器可以并行处理。</li><li>支持HTTP下的安全套接层安全协议SSL.</li><li>支持基于加权和依赖的优先权的HTTP/2</li></ul><h4 id="高级HTTP服务"><a href="#高级HTTP服务" class="headerlink" title="高级HTTP服务"></a>高级HTTP服务</h4><ul><li>支持基于名字和IP的虚拟主机设置</li><li>支持HTTP/1.0中的KEEP-Alive模式和管线(PipeLined)模型连接</li><li>自定义访问日志格式、带缓存的日志写操作以及快速日志轮转。</li><li>提供3xx~5xx错误代码重定向功能</li><li>支持重写（Rewrite)模块扩展</li><li>支持重新加载配置以及在线升级时无需中断正在处理的请求</li><li>支持网络监控</li><li>支持FLV和MP4流媒体传输</li></ul><h4 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h4><p>Nginx提供邮件代理服务也是其基本开发需求之一，主要包含以下特性：</p><ul><li>支持IMPA/POP3代理服务功能</li><li>支持内部SMTP代理服务功能</li></ul><h4 id="Nginx常用的功能模块"><a href="#Nginx常用的功能模块" class="headerlink" title="Nginx常用的功能模块"></a>Nginx常用的功能模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">静态资源部署</span><br><span class="line">Rewrite地址重写</span><br><span class="line">正则表达式</span><br><span class="line">反向代理</span><br><span class="line">负载均衡</span><br><span class="line">轮询、加权轮询、ip_hash、url_hash、fair</span><br><span class="line">Web缓存</span><br><span class="line">环境部署</span><br><span class="line">高可用的环境</span><br><span class="line">用户认证模块...</span><br></pre></td></tr></table></figure><p>Nginx的核心组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx二进制可执行文件</span><br><span class="line">nginx.conf配置文件</span><br><span class="line">error.log错误的日志记录</span><br><span class="line">access.log访问日志记录</span><br></pre></td></tr></table></figure><h2 id="Nginx环境准备"><a href="#Nginx环境准备" class="headerlink" title="Nginx环境准备"></a>Nginx环境准备</h2><h3 id="Nginx版本介绍"><a href="#Nginx版本介绍" class="headerlink" title="Nginx版本介绍"></a>Nginx版本介绍</h3><p>Nginx的官方网站为: <a href="http://nginx.org/">http://nginx.org</a></p><p>打开源码可以看到如下的页面内容</p><p><img src="https://s1.ax1x.com/2023/03/13/ppQnACF.png" alt="在这里插入图片描述"></p><p>Nginx的官方下载网站为<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a>，当然你也可以之间在首页选中右边的download进入版本下载网页。在下载页面我们会看到如下内容：</p><p><img src="https://s1.ax1x.com/2023/03/13/ppQnE34.png" alt="在这里插入图片描述"></p><h3 id="获取Nginx源码"><a href="#获取Nginx源码" class="headerlink" title="获取Nginx源码"></a>获取Nginx源码</h3><p><a href="http://nginx.org/download/">http://nginx.org/download/</a></p><p>打开上述网站，就可以查看到Nginx的所有版本，选中自己需要的版本进行下载。下载我们可以直接在windows上下载然后上传到服务器，也可以直接从服务器上下载，这个时候就需要准备一台服务器。</p><p><img src="https://z4a.net/images/2023/03/13/5b9a267e83ff4a05bb2cae0ddaf8c5ba.png" alt="在这里插入图片描述"></p><h3 id="准备服务器系统"><a href="#准备服务器系统" class="headerlink" title="准备服务器系统"></a>准备服务器系统</h3><p>环境准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VMware WorkStation</span><br><span class="line">Centos7</span><br><span class="line">MobaXterm</span><br><span class="line">xsheel,SecureCRT</span><br><span class="line">网络</span><br></pre></td></tr></table></figure><p>(1)确认centos的内核</p><p>准备一个内核为2.6及以上版本的操作系统，因为linux2.6及以上内核才支持epoll,而Nginx需要解决高并发压力问题是需要用到epoll，所以我们需要有这样的版本要求。</p><p>我们可以使用<code>uname -a</code>命令来查询linux的内核版本。</p><p><img src="https://z4a.net/images/2023/03/13/4579d240547a4df596868fe72ca62928.png" alt="在这里插入图片描述"></p><p>(2)确保centos能联网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2023/03/13/82c54ad7bba9424fa4e58f833f13d0ea.png" alt="在这里插入图片描述"></p><p>(3)确认关闭防火墙</p><p>这一项的要求仅针对于那些对linux系统的防火墙设置规则不太清楚的，建议大家把防火墙都关闭掉，因为我们此次课程主要的内容是对Nginx的学习，把防火墙关闭掉，可以省掉后续Nginx学习过程中遇到的诸多问题。</p><p>关闭的方式有如下两种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld      关闭运行的防火墙，系统重新启动后，防火墙将重新打开</span><br><span class="line">systemctl disable firewalld   永久关闭防火墙，，系统重新启动后，防火墙依然关闭</span><br><span class="line">systemctl status firewalld 查看防火墙状态</span><br></pre></td></tr></table></figure><p>（4）确认停用selinux</p><p>selinux(security-enhanced linux),美国安全局对于强制访问控制的实现，在linux2.6内核以后的版本中，selinux已经成功内核中的一部分。可以说selinux是linux史上最杰出的新安全子系统之一。虽然有了selinux，我们的系统会更安全，但是对于我们的学习Nginx的历程中，会多很多设置，所以这块建议大家将selinux进行关闭。</p><p><img src="https://z4a.net/images/2023/03/13/8f2431de204947bab7cc5de1d69f641e.png" alt="在这里插入图片描述"></p><p>sestatus查看状态</p><p><img src="https://z4a.net/images/2023/03/13/eaa69c26076d4ca292e7a4315620d52b.png" alt="在这里插入图片描述"></p><p>如果查看不是disabled状态，我们可以通过修改配置文件来进行设置,修改SELINUX=disabled，然后重启下系统即可生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2023/03/13/a485806000214e239fd018e64853b7ba.png" alt="在这里插入图片描述"></p><h3 id="Nginx安装方式介绍"><a href="#Nginx安装方式介绍" class="headerlink" title="Nginx安装方式介绍"></a>Nginx安装方式介绍</h3><p>Nginx的安装方式有两种分别是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过Nginx源码</span><br><span class="line">通过Nginx源码简单安装 (1)</span><br><span class="line">通过Nginx源码复杂安装 (3)</span><br><span class="line">通过yum安装 (2)</span><br></pre></td></tr></table></figure><p>如果通过Nginx源码安装需要提前准备的内容：</p><h5 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h5><p>Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。</p><p>使用命令<code>yum install -y gcc</code>来安装</p><p>安装成功后，可以通过<code>gcc --version</code>来查看gcc是否安装成功</p><h5 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h5><p>Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。</p><p>可以使用命令<code>yum install -y pcre pcre-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa pcre pcre-devel</code>来查看是否安装成功</p><h5 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h5><p>zlib库提供了开发人员的压缩算法，在Nginx的各个模块中需要使用gzip压缩，所以我们也需要提前安装其库及源代码zlib和zlib-devel</p><p>可以使用命令<code>yum install -y zlib zlib-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa zlib zlib-devel</code>来查看是否安装成功</p><h5 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h5><p>OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。</p><p>SSL:Secure Sockets Layer安全套接协议的缩写，可以在Internet上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在Nginx中，如果服务器需要提供安全网页时就需要用到OpenSSL库，所以我们需要对OpenSSL的库文件及它的开发安装包进行一个安装。</p><p>可以使用命令<code>yum install -y openssl openssl-devel</code>来进行安装</p><p>安装成功后，可以通过<code>rpm -qa openssl openssl-devel</code>来查看是否安装成功</p><p>上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装</p><p><code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code>进行全部安装。</p><h4 id="方案一：Nginx的源码简单安装"><a href="#方案一：Nginx的源码简单安装" class="headerlink" title="方案一：Nginx的源码简单安装"></a>方案一：Nginx的源码简单安装</h4><p>(1)进入官网查找需要下载版本的链接地址，然后使用wget命令进行下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure><p>(2)建议大家将下载的资源进行包管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p nginx/core</span><br><span class="line">mv nginx-1.16.1.tar.gz nginx/core</span><br></pre></td></tr></table></figure><p>(3)解压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure><p>(4)进入资源文件中，发现configure</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>(5)编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>(6)安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="方案二：yum安装"><a href="#方案二：yum安装" class="headerlink" title="方案二：yum安装"></a>方案二：yum安装</h4><p>使用源码进行简单安装，我们会发现安装的过程比较繁琐，需要提前准备GCC编译器、PCRE兼容正则表达式库、zlib压缩库、OpenSSL安全通信的软件库包，然后才能进行Nginx的安装。</p><p>（1）安装yum-utils</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum  install -y yum-utils</span><br></pre></td></tr></table></figure><p>（2）添加yum源文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure><p>（3）查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2023/03/13/7d0d7f50f6154cb4ad8873ed7f3521a1.png" alt="在这里插入图片描述"></p><p>（4）使用yum进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yun install -y nginx</span><br></pre></td></tr></table></figure><p>（5）查看nginx的安装位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2023/03/13/a347aaf129ff49d1bd8518aad8caef04.png" alt="在这里插入图片描述"></p><p>（6）启动测试</p><h4 id="方案三-ubuntu下安装"><a href="#方案三-ubuntu下安装" class="headerlink" title="方案三: ubuntu下安装"></a>方案三: ubuntu下安装</h4><p>官方网站上有各个linux发行版的<a href="https://nginx.org/en/linux_packages.html#Ubuntu">安装教程</a><br><strong>Ubuntu</strong><br>安装必备组件：</p><blockquote><p>sudo apt install curl gnupg2 ca-certificates lsb-release ubuntu-keyring </p></blockquote><p>导入一个官方的nginx签名密钥，以便apt可以验证软件包的真实性。获取密钥：</p><blockquote><p>curl <a href="https://nginx.org/keys/nginx_signing.key">https://nginx.org/keys/nginx_signing.key</a> | gpg –dearmor \     | sudo tee /usr/share/keyrings/nginx-archive-keyring.gpg &gt;/dev/null </p></blockquote><p>验证下载的文件是否包含正确的密钥：</p><blockquote><p>gpg –dry-run –quiet –no-keyring –import –import-options import-show /usr/share/keyrings/nginx-archive-keyring.gpg </p></blockquote><p>输出应包含完整的指纹，如下所示573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62:</p><blockquote><p>pub   rsa2048 2011-08-19 [SC] [expires: 2024-06-14]       573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62 uid                      nginx signing key <a href="mailto:&#x73;&#x69;&#103;&#x6e;&#x69;&#110;&#103;&#x2d;&#107;&#101;&#121;&#x40;&#110;&#103;&#105;&#x6e;&#x78;&#46;&#x63;&#x6f;&#109;">&#x73;&#x69;&#103;&#x6e;&#x69;&#110;&#103;&#x2d;&#107;&#101;&#121;&#x40;&#110;&#103;&#105;&#x6e;&#x78;&#46;&#x63;&#x6f;&#109;</a> </p></blockquote><p>如果指纹不同，请删除该文件。<br>要为稳定的nginx软件包设置apt存储库，请运行以下命令：</p><blockquote><p>echo “deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \ <a href="http://nginx.org/packages/ubuntu">http://nginx.org/packages/ubuntu</a> <code>lsb_release -cs</code> nginx” \     | sudo tee /etc/apt/sources.list.d/nginx.list </p></blockquote><p>如果你想使用主线nginx包，请改为运行以下命令：</p><blockquote><p>echo “deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \ <a href="http://nginx.org/packages/mainline/ubuntu">http://nginx.org/packages/mainline/ubuntu</a> <code>lsb_release -cs</code> nginx” \     | sudo tee /etc/apt/sources.list.d/nginx.list </p></blockquote><p>设置存储库固定，以优先选择我们的软件包而不是分发版提供的软件包：</p><blockquote><p>echo -e “Package: *\nPin: origin nginx.org\nPin: release o=nginx\nPin-Priority: 900\n” \     | sudo tee /etc/apt/preferences.d/99nginx </p></blockquote><p>要安装 nginx，请运行以下命令：</p><blockquote><p>sudo apt update<br>sudo apt install nginx </p></blockquote><h4 id="源码简单安装和yum安装的差异："><a href="#源码简单安装和yum安装的差异：" class="headerlink" title="源码简单安装和yum安装的差异："></a>源码简单安装和yum安装的差异：</h4><p>这里先介绍一个命令: <code>./nginx -V</code>,通过该命令可以查看到所安装Nginx的版本及相关配置信息。</p><p>简单安装</p><p><img src="https://z4a.net/images/2023/03/13/536246c7b0b14e2b829f3427331902a0.png" alt="在这里插入图片描述"></p><p>yum安装</p><p><img src="https://z4a.net/images/2023/03/13/e555308fb24f403ebe28bd2e6123d72a.png" alt="在这里插入图片描述"></p><h5 id="解压Nginx目录"><a href="#解压Nginx目录" class="headerlink" title="解压Nginx目录"></a>解压Nginx目录</h5><p>执行<code>tar -zxvf nginx-1.16.1.tar.gz</code>对下载的资源进行解压缩，进入压缩后的目录，可以看到如下结构</p><p><img src="https://s1.ax1x.com/2023/03/13/ppleNcj.png" alt="在这里插入图片描述"></p><p>内容解释：</p><p>auto:存放的是编译相关的脚本</p><p>CHANGES:版本变更记录</p><p>CHANGES.ru:俄罗斯文的版本变更记录</p><p>conf:nginx默认的配置文件</p><p>configure:nginx软件的自动脚本程序,是一个比较重要的文件，作用如下：</p><pre><code>（1）检测环境及根据环境检测结果生成C代码（2）生成编译代码需要的Makefile文件</code></pre><p>contrib:存放的是几个特殊的脚本文件，其中README中对脚本有着详细的说明</p><p>html:存放的是Nginx自带的两个html页面，访问Nginx的首页和错误页面</p><p>LICENSE:许可证的相关描述文件</p><p>man:nginx的man手册</p><p>README:Nginx的阅读指南</p><p>src:Nginx的源代码</p><h4 id="方案四-Nginx的源码复杂安装"><a href="#方案四-Nginx的源码复杂安装" class="headerlink" title="方案四:Nginx的源码复杂安装"></a>方案四:Nginx的源码复杂安装</h4><p>这种方式和简单的安装配置不同的地方在第一步，通过<code>./configure</code>来对编译参数进行设置，需要我们手动来指定。那么都有哪些参数可以进行设置，接下来我们进行一个详细的说明。</p><p>PATH:是和路径相关的配置信息</p><p>with:是启动模块，默认是关闭的</p><p>without:是关闭模块，默认是开启的</p><p>我们先来认识一些简单的路径配置已经通过这些配置来完成一个简单的编译：</p><p>–prefix=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向Nginx的安装目录，默认值为/usr/local/nginx</span><br></pre></td></tr></table></figure><p>–sbin-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向(执行)程序文件(nginx)的路径,默认值为&lt;prefix&gt;/sbin/nginx</span><br></pre></td></tr></table></figure><p>–modules-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向Nginx动态模块安装目录，默认值为&lt;prefix&gt;/modules</span><br></pre></td></tr></table></figure><p>–conf-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向配置文件(nginx.conf)的路径,默认值为&lt;prefix&gt;/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>–error-log-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向错误日志文件的路径,默认值为&lt;prefix&gt;/logs/error.log</span><br></pre></td></tr></table></figure><p>–http-log-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向访问日志文件的路径,默认值为&lt;prefix&gt;/logs/access.log</span><br></pre></td></tr></table></figure><p>–pid-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向Nginx启动后进行ID的文件路径，默认值为&lt;prefix&gt;/logs/nginx.pid</span><br></pre></td></tr></table></figure><p>–lock-path=PATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向Nginx锁文件的存放路径,默认值为&lt;prefix&gt;/logs/nginx.lock</span><br></pre></td></tr></table></figure><p>要想使用可以通过如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx \</span><br><span class="line">--sbin-path=/usr/local/nginx/sbin/nginx \</span><br><span class="line">--modules-path=/usr/local/nginx/modules \</span><br><span class="line">--conf-path=/usr/local/nginx/conf/nginx.conf \</span><br><span class="line">--error-log-path=/usr/local/nginx/logs/error.log \</span><br><span class="line">--http-log-path=/usr/local/nginx/logs/access.log \</span><br><span class="line">--pid-path=/usr/local/nginx/logs/nginx.pid \</span><br><span class="line">--lock-path=/usr/local/nginx/logs/nginx.lock</span><br></pre></td></tr></table></figure><p>在使用上述命令之前，需要将之前服务器已经安装的nginx进行卸载，卸载的步骤分为三步骤：</p><p>步骤一：需要将nginx的进程关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure><p>步骤二:将安装的nginx进行删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/local/nginx</span><br></pre></td></tr></table></figure><p>步骤三:将安装包之前编译的环境清除掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><h3 id="Nginx目录结构分析"><a href="#Nginx目录结构分析" class="headerlink" title="Nginx目录结构分析"></a>Nginx目录结构分析</h3><p>在使用Nginx之前，我们先对安装好的Nginx目录文件进行一个分析，在这块给大家介绍一个工具tree，通过tree我们可以很方面的去查看centos系统上的文件目录结构，当然，如果想使用tree工具，就得先通过<code>yum install -y tree</code>来进行安装，安装成功后，可以通过执行<code>tree /usr/local/nginx</code>(tree后面跟的是Nginx的安装目录)，获取的结果如下：</p><p><img src="https://s1.ax1x.com/2023/03/13/pplet3Q.png" alt="在这里插入图片描述"></p><p>conf:nginx所有配置文件目录</p><pre><code>CGI(Common Gateway Interface)通用网关【接口】，主要解决的问题是从客户端发送一个请求和数据，服务端获取到请求和数据后可以调用调用CGI【程序】处理及相应结果给客户端的一种标准规范。fastcgi.conf:fastcgi相关配置文件fastcgi.conf.default:fastcgi.conf的备份文件fastcgi_params:fastcgi的参数文件fastcgi_params.default:fastcgi的参数备份文件scgi_params:scgi的参数文件scgi_params.default：scgi的参数备份文件uwsgi_params:uwsgi的参数文件uwsgi_params.default:uwsgi的参数备份文件mime.types:记录的是HTTP协议中的Content-Type的值和文件后缀名的对应关系mime.types.default:mime.types的备份文件nginx.conf:这个是Nginx的核心配置文件，这个文件非常重要，也是我们即将要学习的重点nginx.conf.default:nginx.conf的备份文件koi-utf、koi-win、win-utf这三个文件都是与编码转换映射相关的配置文件，用来将一种编码转换成另一种编码</code></pre><p>html:存放nginx自带的两个静态的html页面</p><pre><code>50x.html:访问失败后的失败页面index.html:成功访问的默认首页</code></pre><p>logs:记录入门的文件，当nginx服务器启动后，这里面会有 access.log error.log 和nginx.pid三个文件出现。</p><p>sbin:是存放执行程序文件nginx</p><pre><code>nginx是用来控制Nginx的启动和停止等相关的命令。</code></pre><h3 id="Nginx服务器启停命令"><a href="#Nginx服务器启停命令" class="headerlink" title="Nginx服务器启停命令"></a>Nginx服务器启停命令</h3><p>Nginx安装完成后，接下来我们要学习的是如何启动、重启和停止Nginx的服务。</p><p>对于Nginx的启停在linux系统中也有很多种方式，我们本次课程介绍两种方式：</p><ol><li> Nginx服务的信号控制 </li><li> Nginx的命令行控制 </li></ol><h4 id="方式一-Nginx服务的信号控制"><a href="#方式一-Nginx服务的信号控制" class="headerlink" title="方式一:Nginx服务的信号控制"></a>方式一:Nginx服务的信号控制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Nginx中的master和worker进程?</span><br><span class="line">Nginx的工作方式?</span><br><span class="line">如何获取进程的PID?</span><br><span class="line">信号有哪些?</span><br><span class="line">如何通过信号控制Nginx的启停等相关操作?</span><br></pre></td></tr></table></figure><p>前面在提到Nginx的高性能，其实也和它的架构模式有关。Nginx默认采用的是多进程的方式来工作的，当将Nginx启动后，我们通过<code>ps -ef | grep nginx</code>命令可以查看到如下内容：</p><p><img src="https://s1.ax1x.com/2023/03/13/ppleG4S.png" alt="在这里插入图片描述"></p><p>从上图中可以看到,Nginx后台进程中包含一个master进程和多个worker进程，master进程主要用来管理worker进程，包含接收外界的信息，并将接收到的信号发送给各个worker进程，监控worker进程的状态，当worker进程出现异常退出后，会自动重新启动新的worker进程。而worker进程则是专门用来处理用户请求的，各个worker进程之间是平等的并且相互独立，处理请求的机会也是一样的。nginx的进程模型，我们可以通过下图来说明下：</p><p><img src="https://s1.ax1x.com/2023/03/13/pple8N8.png" alt="在这里插入图片描述"></p><p>我们现在作为管理员，只需要通过给master进程发送信号就可以来控制Nginx,这个时候我们需要有两个前提条件，一个是要操作的master进程，一个是信号。</p><p>（1）要想操作Nginx的master进程，就需要获取到master进程的进程号ID。获取方式简单介绍两个，</p><p>方式一：通过<code>ps -ef | grep nginx</code>；</p><p>方式二：在讲解nginx的<code>./configure</code>的配置参数的时候，有一个参数是<code>--pid-path=PATH</code>默认是<code>/usr/local/nginx/logs/nginx.pid</code>,所以可以通过查看该文件来获取nginx的master进程ID.</p><p>（2）信号</p><table><thead><tr><th>信号</th><th>作用</th></tr></thead><tbody><tr><td>TERM/INT</td><td>立即关闭整个服务</td></tr><tr><td>QUIT</td><td>“优雅”地关闭整个服务</td></tr><tr><td>HUP</td><td>重读配置文件并使用服务对新配置项生效</td></tr><tr><td>USR1</td><td>重新打开日志文件，可以用来进行日志切割</td></tr><tr><td>USR2</td><td>平滑升级到最新版的nginx</td></tr><tr><td>WINCH</td><td>所有子进程不在接收处理新连接，相当于给work进程发送QUIT指令</td></tr></tbody></table><p>调用命令为<code>kill -signal PID</code></p><p>signal:即为信号；PID即为获取到的master线程ID</p><ol><li>发送TERM/INT信号给master进程，会将Nginx服务立即关闭。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -TERM PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class="line">kill -INT PID / kill -INT `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="2"><li>发送QUIT信号给master进程，master进程会控制所有的work进程不再接收新的请求，等所有请求处理完后，在把进程都关闭掉。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="3"><li>发送HUP信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="4"><li>发送USR1信号给master进程，告诉Nginx重新开启日志文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR1 PID / kill -TERM `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><ol start="5"><li>发送USR2信号给master进程，告诉master进程要平滑升级，这个时候，会重新开启对应的master进程和work进程，整个系统中将会有两个master进程，并且新的master进程的PID会被记录在<code>/usr/local/nginx/logs/nginx.pid</code>而之前的旧的master进程PID会被记录在<code>/usr/local/nginx/logs/nginx.pid.oldbin</code>文件中，接着再次发送QUIT信号给旧的master进程，让其处理完请求后再进行关闭</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 PID / kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT PID / kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/03/13/pple3Af.png" alt="在这里插入图片描述"></p><ol start="6"><li>发送WINCH信号给master进程,让master进程控制不让所有的work进程在接收新的请求了，请求处理完后关闭work进程。注意master进程不会被关闭掉</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH PID /kill -WINCH`cat /usr/local/nginx/logs/nginx.pid`</span><br></pre></td></tr></table></figure><h4 id="方式二-Nginx的命令行控制"><a href="#方式二-Nginx的命令行控制" class="headerlink" title="方式二:Nginx的命令行控制"></a>方式二:Nginx的命令行控制</h4><p>此方式是通过Nginx安装目录下的sbin下的可执行文件nginx来进行Nginx状态的控制，我们可以通过<code>nginx -h</code>来查看都有哪些参数可以用：</p><p><img src="https://s1.ax1x.com/2023/03/13/pplelHP.png" alt="在这里插入图片描述"></p><p>-?和-h:显示帮助信息</p><p>-v:打印版本号信息并退出</p><p>-V:打印版本号信息和配置信息并退出</p><p>-t:测试nginx的配置文件语法是否正确并退出</p><p>-T:测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出</p><p>-q:在配置测试期间禁止显示非错误消息</p><p>-s:signal信号，后面可以跟 ：</p><pre><code> stop[快速关闭，类似于TERM/INT信号的作用]quit[优雅的关闭，类似于QUIT信号的作用]reopen[重新打开日志文件类似于USR1信号的作用]reload[类似于HUP信号的作用]</code></pre><p>-p:prefix，指定Nginx的prefix路径，(默认为: /usr/local/nginx/)</p><p>-c:filename,指定Nginx的配置文件路径,(默认为: conf/nginx.conf)</p><p>-g:用来补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置</p><h3 id="Nginx服务器版本升级和新增模块"><a href="#Nginx服务器版本升级和新增模块" class="headerlink" title="Nginx服务器版本升级和新增模块"></a>Nginx服务器版本升级和新增模块</h3><p>如果想对Nginx的版本进行更新，或者要应用一些新的模块，最简单的做法就是停止当前的Nginx服务，然后开启新的Nginx服务。但是这样会导致在一段时间内，用户是无法访问服务器。为了解决这个问题，我们就需要用到Nginx服务器提供的平滑升级功能。这个也是Nginx的一大特点，使用这种方式，就可以使Nginx在7*24小时不间断的提供服务了。接下来我们分析下需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求：Nginx的版本最开始使用的是Nginx-1.14.2,由于服务升级，需要将Nginx的版本升级到Nginx-1.16.1,要求Nginx不能中断提供服务。</span><br></pre></td></tr></table></figure><p>为了应对上述的需求，这里我们给大家提供两种解决方案:</p><p>方案一:使用Nginx服务信号完成Nginx的升级</p><p>方案二:使用Nginx安装目录的make命令完成升级</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>（1）先准备两个版本的Nginx分别是 1.14.2和1.16.1</p><p>（2）使用Nginx源码安装的方式将1.14.2版本安装成功并正确访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入安装目录</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>（3）将Nginx1.16.1进行参数配置和编译，不需要进行安装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入安装目录</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h4 id="方案一-使用Nginx服务信号进行升级"><a href="#方案一-使用Nginx服务信号进行升级" class="headerlink" title="方案一:使用Nginx服务信号进行升级"></a>方案一:使用Nginx服务信号进行升级</h4><p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">mv nginx nginxold</span><br></pre></td></tr></table></figure><p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/nginx/core/nginx-1.16.1/objs</span><br><span class="line">cp nginx /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>第三步:发送信号USR2给Nginx的1.14.2版本对应的master进程</p><p>第四步:发送信号QUIT给Nginx的1.14.2版本对应的master进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT `more /usr/local/logs/nginx.pid.oldbin`</span><br></pre></td></tr></table></figure><h4 id="方案二-使用Nginx安装目录的make命令完成升级"><a href="#方案二-使用Nginx安装目录的make命令完成升级" class="headerlink" title="方案二:使用Nginx安装目录的make命令完成升级"></a>方案二:使用Nginx安装目录的make命令完成升级</h4><p>第一步:将1.14.2版本的sbin目录下的nginx进行备份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">mv nginx nginxold</span><br></pre></td></tr></table></figure><p>第二步:将Nginx1.16.1安装目录编译后的objs目录下的nginx文件，拷贝到原来<code>/usr/local/nginx/sbin</code>目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/nginx/core/nginx-1.16.1/objs</span><br><span class="line">cp nginx /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>第三步:进入到安装目录，执行<code>make upgrade</code></p><p><img src="https://s1.ax1x.com/2023/03/13/ppleQBt.png" alt="在这里插入图片描述"></p><p>第四步:查看是否更新成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -v</span><br></pre></td></tr></table></figure><p>在整个过程中，其实Nginx是一直对外提供服务的。并且当Nginx的服务器启动成功后，我们是可以通过浏览器进行直接访问的，同时我们可以通过更改html目录下的页面来修改我们在页面上所看到的内容，那么问题来了，为什么我们要修改html目录下的文件，能不能多添加一些页面是Nginx的功能更加丰富，还有前面聊到Nginx的前端功能又是如何来实现的，这就需要我们对Nginx的核心配置文件进行一个详细的学习。</p><h2 id="Nginx核心配置文件结构"><a href="#Nginx核心配置文件结构" class="headerlink" title="Nginx核心配置文件结构"></a>Nginx核心配置文件结构</h2><p>从前面的内容学习中，我们知道Nginx的核心配置文件默认是放在<code>/usr/local/nginx/conf/nginx.conf</code>，这一节，我们就来学习下nginx.conf的内容和基本配置方法。</p><p>读取Nginx自带的Nginx配置文件，我们将其中的注释部分【学习一个技术点就是在Nginx的配置文件中可以使用<code>#</code>来注释】删除掉后，就剩下下面内容:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">指令名指令值;  #全局块，主要设置Nginx服务器整体运行的配置指令</span><br><span class="line"></span><br><span class="line"> #events块,主要设置,Nginx服务器与用户的网络连接,这一部分对Nginx服务器的性能影响较大</span><br><span class="line">events &#123; </span><br><span class="line">    指令名指令值;</span><br><span class="line">&#125;</span><br><span class="line">#http块，是Nginx服务器配置中的重要部分，代理、缓存、日志记录、第三方模块配置...             </span><br><span class="line">http &#123;</span><br><span class="line">    指令名指令值;</span><br><span class="line">    server &#123; #server块，是Nginx配置和虚拟主机相关的内容</span><br><span class="line">        指令名指令值;</span><br><span class="line">        location / &#123; </span><br><span class="line">        #location块，基于Nginx服务器接收请求字符串与location后面的值进行匹配，对特定请求进行处理</span><br><span class="line">            指令名指令值;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单小结下:</p><p>nginx.conf配置文件中默认有三大块：全局块、events块、http块</p><p>http块中可以配置多个server块，每个server块又可以配置多个location块。</p><h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><h4 id="user指令"><a href="#user指令" class="headerlink" title="user指令"></a>user指令</h4><p>（1）user:用于配置运行Nginx服务器的worker进程的用户和用户组。</p><table><thead><tr><th>语法</th><th>user user [group]</th></tr></thead><tbody><tr><td>默认值</td><td>nobody</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>该属性也可以在编译的时候指定，语法如下<code>./configure --user=user --group=group</code>,如果两个地方都进行了设置，最终生效的是配置文件中的配置。</p><p>该指令的使用步骤:</p><p>(1)设置一个用户信息”www”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user www;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/03/13/ppleMnI.png" alt="在这里插入图片描述"></p><p>(2) 创建一个用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd www</span><br></pre></td></tr></table></figure><p>(3)修改user属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user www</span><br></pre></td></tr></table></figure><p>(4)创建<code>/root/html/index.html</code>页面，添加如下内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">35em</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-family</span>: Tahoma, Verdana, Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>For online documentation and support please refer to</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;</span>nginx.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Commercial support is available at</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;</span>nginx.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Thank you for using nginx.<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>I am WWW<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(5)修改nginx.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root   /root/html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5)测试启动访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面会报403拒绝访问的错误</span><br></pre></td></tr></table></figure><p>(6)分析原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为当前用户没有访问/root/html目录的权限</span><br></pre></td></tr></table></figure><p>(7)将文件创建到 <code>/home/www/html/index.html</code>,修改配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root   /home/www/html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(8)再次测试启动访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能正常访问。</span><br></pre></td></tr></table></figure><p>综上所述，使用user指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全。</p><h4 id="work-process指令"><a href="#work-process指令" class="headerlink" title="work process指令"></a>work process指令</h4><p>master_process:用来指定是否开启工作进程。</p><table><thead><tr><th>语法</th><th>master_process on&#124;off;</th></tr></thead><tbody><tr><td>默认值</td><td>master_process on;</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>worker_processes:用于配置Nginx生成工作进程的数量，这个是Nginx服务器实现并发处理服务的关键所在。理论上来说workder process的值越大，可以支持的并发处理量也越多，但事实上这个值的设定是需要受到来自服务器自身的限制，建议将该值和服务器CPU的内核数保存一致。</p><table><thead><tr><th>语法</th><th>worker_processes     num/auto;</th></tr></thead><tbody><tr><td>默认值</td><td>1</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>如果将worker_processes设置成2，则会看到如下内容:</p><p><img src="https://s1.ax1x.com/2023/03/13/ppleujA.png" alt="在这里插入图片描述"></p><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><p>daemon：设定Nginx是否以守护进程的方式启动。</p><p>守护式进程是linux后台执行的一种服务进程，特点是独立于控制终端，不会随着终端关闭而停止。</p><table><thead><tr><th>语法</th><th>daemon on&#124;off;</th></tr></thead><tbody><tr><td>默认值</td><td>daemon on;</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>pid:用来配置Nginx当前master进程的进程号ID存储的文件路径。</p><table><thead><tr><th>语法</th><th>pid file;</th></tr></thead><tbody><tr><td>默认值</td><td>默认为:/usr/local/nginx/logs/nginx.pid</td></tr><tr><td>位置</td><td>全局块</td></tr></tbody></table><p>该属性可以通过<code>./configure --pid-path=PATH</code>来指定</p><p>error_log:用来配置Nginx的错误日志存放路径</p><table><thead><tr><th>语法</th><th>error_log  file [日志级别];</th></tr></thead><tbody><tr><td>默认值</td><td>error_log logs/error.log error;</td></tr><tr><td>位置</td><td>全局块、http、server、location</td></tr></tbody></table><p>该属性可以通过<code>./configure --error-log-path=PATH</code>来指定</p><p>其中日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg，翻译过来为试|信息|通知|警告|错误|临界|警报|紧急，这块建议大家设置的时候不要设置成info以下的等级，因为会带来大量的磁盘I/O消耗，影响Nginx的性能。</p><p>（5）include:用来引入其他配置文件，使Nginx的配置更加灵活</p><table><thead><tr><th>语法</th><th>include file;</th></tr></thead><tbody><tr><td>默认值</td><td>无</td></tr><tr><td>位置</td><td>any</td></tr></tbody></table><h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><p>（1）accept_mutex:用来设置Nginx网络连接序列化</p><table><thead><tr><th>语法</th><th>accept_mutex on&#124;off;</th></tr></thead><tbody><tr><td>默认值</td><td>accept_mutex on;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table><p>这个配置主要可以用来解决常说的”惊群”问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx后台是以多进程的工作模式，也就是说有多个worker进程会被同时唤醒，但是最终只会有一个进程可以获取到连接，如果每次唤醒的进程数目太多，就会影响Nginx的整体性能。如果将上述值设置为on(开启状态)，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。</p><p><img src="https://s1.ax1x.com/2023/03/13/ppleEtO.png" alt="在这里插入图片描述"></p><p>（2）multi_accept:用来设置是否允许同时接收多个网络连接</p><table><thead><tr><th>语法</th><th>multi_accept on&#124;off;</th></tr></thead><tbody><tr><td>默认值</td><td>multi_accept off;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table><p>如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接</p><p>（3）worker_connections：用来配置单个worker进程最大的连接数</p><table><thead><tr><th>语法</th><th>worker_connections number;</th></tr></thead><tbody><tr><td>默认值</td><td>worker_commections 512;</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table><p>这里的连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数。另外，number值不能大于操作系统支持打开的最大文件句柄数量。</p><p>（4）use:用来设置Nginx服务器选择哪种事件驱动来处理网络消息。</p><table><thead><tr><th>语法</th><th>use  method;</th></tr></thead><tbody><tr><td>默认值</td><td>根据操作系统定</td></tr><tr><td>位置</td><td>events</td></tr></tbody></table><p>注意：此处所选择事件处理模型是Nginx优化部分的一个重要内容，method的可选值有select/poll/epoll/kqueue等，之前在准备centos环境的时候，我们强调过要使用linux内核在2.6以上，就是为了能使用epoll函数来优化Nginx。</p><p>另外这些值的选择，我们也可以在编译的时候使用</p><p><code>--with-select_module</code>、<code>--without-select_module</code>、</p><p><code>--with-poll_module</code>、<code>--without-poll_module</code>来设置是否需要将对应的事件驱动模块编译到Nginx的内核。</p><h4 id="events指令配置实例"><a href="#events指令配置实例" class="headerlink" title="events指令配置实例"></a>events指令配置实例</h4><p>打开Nginx的配置文件 nginx.conf,添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events&#123;</span><br><span class="line">accept_mutex on;</span><br><span class="line">multi_accept on;</span><br><span class="line">worker_commections 1024;</span><br><span class="line">use epoll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx -t</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><h4 id="定义MIME-Type"><a href="#定义MIME-Type" class="headerlink" title="定义MIME-Type"></a>定义MIME-Type</h4><p>我们都知道浏览器中可以显示的内容有HTML、XML、GIF等种类繁多的文件、媒体等资源，浏览器为了区分这些资源，就需要使用MIME Type。所以说MIME Type是网络资源的媒体类型。Nginx作为web服务器，也需要能够识别前端请求的资源类型。</p><p>在Nginx的配置文件中，默认有两行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include mime.types;</span><br><span class="line">default_type application/octet-stream;</span><br></pre></td></tr></table></figure><p>（1）default_type:用来配置Nginx响应前端请求默认的MIME类型。</p><table><thead><tr><th>语法</th><th>default_type mime-type;</th></tr></thead><tbody><tr><td>默认值</td><td>default_type text/plain；</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>在default_type之前还有一句<code>include mime.types</code>,include之前我们已经介绍过，相当于把mime.types文件中MIMT类型与相关类型文件的文件后缀名的对应关系加入到当前的配置文件中。</p><p>举例来说明：</p><p>有些时候请求某些接口的时候需要返回指定的文本字符串或者json字符串，如果逻辑非常简单或者干脆是固定的字符串，那么可以使用nginx快速实现，这样就不用编写程序响应请求了，可以减少服务器资源占用并且响应性能非常快。</p><p>如何实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /get_text &#123;</span><br><span class="line">#这里也可以设置成text/plain</span><br><span class="line">    default_type text/html;</span><br><span class="line">    return 200 &quot;This is nginx&#x27;s text&quot;;</span><br><span class="line">&#125;</span><br><span class="line">location /get_json&#123;</span><br><span class="line">    default_type application/json;</span><br><span class="line">    return 200 &#x27;&#123;&quot;name&quot;:&quot;TOM&quot;,&quot;age&quot;:18&#125;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义服务日志"><a href="#自定义服务日志" class="headerlink" title="自定义服务日志"></a>自定义服务日志</h4><p>Nginx中日志的类型分access.log、error.log。</p><p>access.log:用来记录用户所有的访问请求。</p><p>error.log:记录nginx本身运行时的错误信息，不会记录用户的访问请求。</p><p>Nginx服务器支持对服务日志的格式、大小、输出等进行设置，需要使用到两个指令，分别是access_log和log_format指令。</p><p>（1）access_log:用来设置用户访问日志的相关属性。</p><table><thead><tr><th>语法</th><th>access_log path[format[buffer=size]]</th></tr></thead><tbody><tr><td>默认值</td><td>access_log logs/access.log combined;</td></tr></tbody></table><p>| 位置 | <code>http</code><br>, <code>server</code><br>, <code>location</code> |</p><p>（2）log_format:用来指定日志的输出格式。</p><table><thead><tr><th>语法</th><th>log_format name [escape=default&#124;json&#124;none] string….;</th></tr></thead><tbody><tr><td>默认值</td><td>log_format combined “…”;</td></tr><tr><td>位置</td><td>http</td></tr></tbody></table><h4 id="其他配置指令"><a href="#其他配置指令" class="headerlink" title="其他配置指令"></a>其他配置指令</h4><p>（1）sendfile:用来设置Nginx服务器是否使用sendfile()传输文件，该属性可以大大提高Nginx处理静态资源的性能</p><table><thead><tr><th>语法</th><th>sendfile on&#124;off；</th></tr></thead><tbody><tr><td>默认值</td><td>sendfile off;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（2）keepalive_timeout:用来设置长连接的超时时间。</p><p>》为什么要使用keepalive？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们都知道HTTP是一种无状态协议，客户端向服务端发送一个TCP请求，服务端响应完毕后断开连接。</span><br><span class="line">如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接，效率相对来说比较多，使用keepalive模式，可以告诉服务器端在处理完一个请求后保持这个TCP连接的打开状态，若接收到来自这个客户端的其他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时间。</span><br></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>keepalive_timeout time;</th></tr></thead><tbody><tr><td>默认值</td><td>keepalive_timeout 75s;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><p>（3）keepalive_requests:用来设置一个keep-alive连接使用的次数。</p><table><thead><tr><th>语法</th><th>keepalive_requests number;</th></tr></thead><tbody><tr><td>默认值</td><td>keepalive_requests 100;</td></tr><tr><td>位置</td><td>http、server、location</td></tr></tbody></table><h3 id="server块和location块"><a href="#server块和location块" class="headerlink" title="server块和location块"></a>server块和location块</h3><p>server块和location块都是我们要重点讲解和学习的内容，因为我们后面会对Nginx的功能进行详细讲解，所以这块内容就放到静态资源部署的地方给大家详细说明。</p><p>本节我们主要来认识下Nginx默认给的nginx.conf中的相关内容，以及server块与location块在使用的时候需要注意的一些内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       server_name  localhost;</span><br><span class="line">       location / &#123;</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       error_page   500 502 503 504 404  /50x.html;</span><br><span class="line">       location = /50x.html &#123;</span><br><span class="line">           root   html;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习的过程中发现有现成的笔记，所以就不再自己写了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Nginx简介&quot;&gt;&lt;a href=&quot;#Nginx简介&quot; class=&quot;headerlink&quot; title=&quot;Nginx简介&quot;&gt;&lt;/a&gt;Nginx简</summary>
      
    
    
    
    <category term="Nginx" scheme="https://kallenblue.github.io/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务-Nacos配置原理</title>
    <link href="https://kallenblue.github.io/2022/10/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Nacos%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>https://kallenblue.github.io/2022/10/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Nacos%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</id>
    <published>2022-10-16T13:39:07.000Z</published>
    <updated>2023-03-13T15:56:35.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos实现配置管理"><a href="#Nacos实现配置管理" class="headerlink" title="Nacos实现配置管理"></a>Nacos实现配置管理</h1><ul><li><p>配置管理原理<br><img src="https://z4a.net/images/2023/03/13/14fdc99f14194aa2b23ea354a8eb2dd6.png"></p></li><li><p>配置过程<br><img src="https://z4a.net/images/2023/03/13/5ba551988503426bbde0b1f4bbab30ce.png"><br><img src="https://z4a.net/images/2023/03/13/f80003109f884e4ea5b9a72d1fa39cd1.png"></p><h1 id="微服务配置拉取"><a href="#微服务配置拉取" class="headerlink" title="微服务配置拉取"></a>微服务配置拉取</h1><h2 id="配置获取步骤"><a href="#配置获取步骤" class="headerlink" title="配置获取步骤"></a>配置获取步骤</h2><p><img src="https://z4a.net/images/2023/03/13/f7b070c0ad6d4ef49f5b8b87958e9660.png"></p></li><li><p>1.引入Nacos的配置管理客户端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos的配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>2.在resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 环境</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><h1 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h1><p><img src="https://z4a.net/images/2023/03/13/bfd904f84f4840f9b608dbddd218d995.png"><br><img src="https://z4a.net/images/2023/03/13/1c25ff68b8b94656a73740768fc7058b.png"><br><img src="https://z4a.net/images/2023/03/13/54f67e45ce324a31a5b5724afc22bbc7.png"></p><h1 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a>多环境配置共享</h1><p><img src="https://z4a.net/images/2023/03/13/e2dc4cbe9f3c4fdfbb07990e3642e27d.png"></p></li><li><p>多环境配置优先级<br><img src="https://z4a.net/images/2023/03/13/1372486e741b410d96fe6c265aae0f67.png"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos实现配置管理&quot;&gt;&lt;a href=&quot;#Nacos实现配置管理&quot; class=&quot;headerlink&quot; title=&quot;Nacos实现配置管理&quot;&gt;&lt;/a&gt;Nacos实现配置管理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配置管理原理&lt;br&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="微服务" scheme="https://kallenblue.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务-Nacos</title>
    <link href="https://kallenblue.github.io/2022/10/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Nacos/"/>
    <id>https://kallenblue.github.io/2022/10/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Nacos/</id>
    <published>2022-10-14T09:16:21.000Z</published>
    <updated>2023-03-13T15:56:35.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h2 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h2><p>开发阶段采用单机安装即可。</p><h3 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h3><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/75804e9a-76b8-42d4-911e-733fa48ac570.png" alt="image-20210402161102887"></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/50c23cae-a096-412a-9af8-3b2c0ac0fdfa.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h3 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h3><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/3b1886ca-470e-47cb-a193-dae5ad063fee.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h3 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h3><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/121512b7-8fb2-431e-ab02-a348ca4adc56.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/cd17c06a-cc4e-4e50-afe6-0d2063e52f5d.png" alt="image-20210402162251093"></p><h3 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h3><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/8fd9af97-7b53-41fd-b3ee-438af9121e82.png" alt="image-20210402162350977"></p><blockquote><p>1.4.4nacos默认要求是使用集群的方式启动，集群要求至少有三台nacos服务器,所以需要修改配置</p></blockquote><p>将set MODE=”cluster”修改为set MODE=”standalone”，再次双击startup.cmd启动即可<br><img src="https://z4a.net/images/2023/03/13/e6c2e0a5f2f64e14906a2cfd92841841.png"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/f8783315-b0b0-4462-870b-de885025d58e.png" alt="image-20210402162526774"></p><h3 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h3><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a> 即可：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/3facf74a-4506-4b39-a4cb-bda3308add4d.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/2ec50808-43df-4093-8e21-e82762d0296c.png" alt="image-20210402162709515"></p><h2 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h2><p>Linux或者Mac安装方式与Windows类似。</p><h3 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h3><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/1211a2fd-f76b-46c9-8a6e-32e8e3cd9fd6.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h3><p>如图：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/26be463c-78c0-441f-b280-351e815330a6.png" alt="image-20210402161102887"></p><p>也可以直接使用tar.gz：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/50c23cae-a096-412a-9af8-3b2c0ac0fdfa.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/e16526ca-acc2-474b-bf8c-95a5a77719e8.png" alt="image-20210402163715580"></p><h3 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h3><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/38a47218-766a-4da6-addc-8ab2b9bb59a4.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/84643c32-9809-41f7-9699-bb1058019660.png" alt="image-20210402164414827"></p><h3 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h3><p>与windows中类似</p><h3 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h3><p>在nacos/bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h1 id="Nacos注册使用"><a href="#Nacos注册使用" class="headerlink" title="Nacos注册使用"></a>Nacos注册使用</h1><h2 id="Nacos的依赖"><a href="#Nacos的依赖" class="headerlink" title="Nacos的依赖"></a>Nacos的依赖</h2><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos的管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置地址信息"><a href="#配置地址信息" class="headerlink" title="配置地址信息"></a>配置地址信息</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务地址</span></span><br></pre></td></tr></table></figure><h1 id="Nacos服务多级存储模型"><a href="#Nacos服务多级存储模型" class="headerlink" title="Nacos服务多级存储模型"></a>Nacos服务多级存储模型</h1><h2 id="Nacos服务分级存储模型"><a href="#Nacos服务分级存储模型" class="headerlink" title="Nacos服务分级存储模型"></a>Nacos服务分级存储模型</h2><p><img src="https://z4a.net/images/2023/03/13/57ad4c30b4a14ebca648a338bb1123eb.png"></p><h2 id="服务跨集群调用问题"><a href="#服务跨集群调用问题" class="headerlink" title="服务跨集群调用问题"></a>服务跨集群调用问题</h2><p><img src="https://z4a.net/images/2023/03/13/ab3561fa71224c74813ea03bc653b424.png"></p><h2 id="模拟集群"><a href="#模拟集群" class="headerlink" title="模拟集群"></a>模拟集群</h2><p>在属性配置中加上集群的配置即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos服务地址</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#集群名称，代指杭州</span></span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2023/03/13/42f57b7cb792429ebec140bb45110f8f.png"></p><h1 id="NacosRule负载均衡"><a href="#NacosRule负载均衡" class="headerlink" title="NacosRule负载均衡"></a>NacosRule负载均衡</h1><p>NacosRule负载均衡策略</p><ul><li>优先选择同集群服务实例列表</li><li>本地集群找不到提供者，才去其它集群寻找，并且会报警告<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-14 23:15:11:759  WARN 25900 --- [nio-8082-exec-5] c.alibaba.cloud.nacos.ribbon.NacosRule   : A cross-cluster call occurs，name = userservice, clusterName = BJ, instance = [Instance&#123;instanceId=&#x27;192.168.137.1#8085#SH#DEFAULT_GROUP@@userservice&#x27;, ip=&#x27;192.168.137.1&#x27;, port=8085, weight=1.0, healthy=true, enabled=true, ephemeral=true, clusterName=&#x27;SH&#x27;, serviceName=&#x27;DEFAULT_GROUP@@userservice&#x27;, metadata=&#123;preserved.register.source=SPRING_CLOUD&#125;&#125;]</span><br></pre></td></tr></table></figure></li><li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li></ul><blockquote><p>设置负载均衡的配置</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span>  <span class="comment"># 负载均衡规则</span></span><br></pre></td></tr></table></figure><h1 id="服务实例权重的设置"><a href="#服务实例权重的设置" class="headerlink" title="服务实例权重的设置"></a>服务实例权重的设置</h1><p><img src="https://z4a.net/images/2023/03/13/d80c9a32261c45ec8f49983c3698e7ba.png"><br><img src="https://z4a.net/images/2023/03/13/a44b90dcd1c44e94b8267a6aaf421c64.png"></p><h1 id="Nacos环境隔离"><a href="#Nacos环境隔离" class="headerlink" title="Nacos环境隔离"></a>Nacos环境隔离</h1><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p><img src="https://z4a.net/images/2023/03/13/ce1c866b7a7f449982ff986262b21efa.png"></p><h2 id="创建新的命名空间"><a href="#创建新的命名空间" class="headerlink" title="创建新的命名空间"></a>创建新的命名空间</h2><ul><li>在Nacos控制台可以创建namespace，用来隔离不同环境<br><img src="https://z4a.net/images/2023/03/13/b22f11f4a7454e648e03b10e5709e95b.png"></li><li>填写一个新的命名空间信息<br><img src="https://z4a.net/images/2023/03/13/ddd09703b9b94964822b459c101e56bd.png"></li><li>保存后可以看到这个命名空间的id<br><img src="https://z4a.net/images/2023/03/13/12d8907678b24bb7b660181aa993ad25.png"></li><li>修改配置文件，添加namespace<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">c241845e-d5a8-4163-83ce-dbfc64754f38</span> <span class="comment">#命名空间id</span></span><br></pre></td></tr></table></figure>不同命名空间的服务不能直接相互调用，否则会报错<h1 id="Nacos注册中心原理"><a href="#Nacos注册中心原理" class="headerlink" title="Nacos注册中心原理"></a>Nacos注册中心原理</h1><h2 id="与eureka的区别"><a href="#与eureka的区别" class="headerlink" title="与eureka的区别"></a>与eureka的区别</h2><img src="https://z4a.net/images/2023/03/13/3c5f9916507b4215aa02d19d28d79031.png"><br><img src="https://z4a.net/images/2023/03/13/f07d4025a35b471a9bea1ab259d6ad20.png"><h2 id="注册非临时实例"><a href="#注册非临时实例" class="headerlink" title="注册非临时实例"></a>注册非临时实例</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nacos安装指南&quot;&gt;&lt;a href=&quot;#Nacos安装指南&quot; class=&quot;headerlink&quot; title=&quot;Nacos安装指南&quot;&gt;&lt;/a&gt;Nacos安装指南&lt;/h1&gt;&lt;h2 id=&quot;1-Windows安装&quot;&gt;&lt;a href=&quot;#1-Windows安装&quot; c</summary>
      
    
    
    
    <category term="微服务" scheme="https://kallenblue.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务-Eureka</title>
    <link href="https://kallenblue.github.io/2022/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Eureka/"/>
    <id>https://kallenblue.github.io/2022/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Eureka/</id>
    <published>2022-10-13T12:52:00.000Z</published>
    <updated>2023-03-10T11:48:07.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Eureka作用"><a href="#Eureka作用" class="headerlink" title="Eureka作用"></a>Eureka作用</h1><ul><li>向消费者提供服务提供者具体信息<ul><li>服务提供者启动时向eureka注册自己的信息</li><li>eureka保存这些信息</li><li>消费者根据服务名称向eureka拉取提供者信息</li></ul></li></ul><ul><li>帮助消费者选择服务提供者<ul><li>服务消费者利用负载均衡算法，从服务列表中挑选一个合适的服务提供者</li></ul></li><li>干着服务提供者健康状态<ul><li>服务提供者每隔30秒想EurekaServer发送心跳请求，报告健康状态</li><li>eureka会更新记录服务列表信息，心跳不正常会被删除</li><li>消费者可以拉取到最新的信息</li></ul></li></ul><h1 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a>搭建EurekaServer</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--eureka服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在启动类中添加-EnableEurekaServer注解"><a href="#在启动类中添加-EnableEurekaServer注解" class="headerlink" title="在启动类中添加@EnableEurekaServer注解"></a>在启动类中添加@EnableEurekaServer注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(EurekaApplication.class,args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写配置"><a href="#编写配置" class="headerlink" title="编写配置"></a>编写配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaserver</span> <span class="comment"># eureka的服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span>  <span class="comment"># eureka的地址信息</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p>服务注册和eureka的注册相同，引入依赖，编写好配置信息即可</p><ul><li>引入依赖<br>这里为客户端依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka客户端依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>编写配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userserver</span> <span class="comment"># eureka的服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span>  <span class="comment"># eureka的地址信息</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h2 id="idea模拟多实例部署"><a href="#idea模拟多实例部署" class="headerlink" title="idea模拟多实例部署"></a>idea模拟多实例部署</h2><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/c4cb11a1-38c8-4f59-b88b-1d465304a7d5.png"></p><blockquote><p>启动情况如下<br><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/80d68b7a-be16-49a5-b165-ec4e3bf2ab8a.png"></p></blockquote><h1 id="完成服务拉取"><a href="#完成服务拉取" class="headerlink" title="完成服务拉取"></a>完成服务拉取</h1><ul><li>修改访问url路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span>+order.getUserId();</span><br></pre></td></tr></table></figure><ul><li>在RestTemplate的bean中加上负载均衡的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="负载均衡流程"><a href="#负载均衡流程" class="headerlink" title="负载均衡流程"></a>负载均衡流程</h1><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/dcf45685-e05d-4382-9130-a442cd15f708.png"><br><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/48459266-b109-498d-9abf-f35da7ed90a7.png"></p><h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><blockquote><p>Ribbon的负载均衡规则是一个叫做IRule的接口来定义的，每一个实现类都是一种规则<br><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/02b76ed4-71dc-456c-b361-8986ed84aacc.png"><br><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/2fe159f3-590f-4630-98b0-22bace140501.png"></p></blockquote><h2 id="修改负载均衡策略"><a href="#修改负载均衡策略" class="headerlink" title="修改负载均衡策略"></a>修改负载均衡策略</h2><p>介绍两种方式</p><ul><li>1.在启动类中定义一个新的IRule的bean<br>这种方式是全局配置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>2.在yml配置文件中添加配置<br>这种方式只针对某一个微服务<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRul</span>  <span class="comment"># 负载均衡规则</span></span><br></pre></td></tr></table></figure><h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2>Ribbon默认采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间较长。<br>而饥饿加载会在项目启动时创建，降低第一次访问的耗时<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启饥饿加载</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="comment"># 指定饥饿加载的服务名称</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Eureka作用&quot;&gt;&lt;a href=&quot;#Eureka作用&quot; class=&quot;headerlink&quot; title=&quot;Eureka作用&quot;&gt;&lt;/a&gt;Eureka作用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;向消费者提供服务提供者具体信息&lt;ul&gt;
&lt;li&gt;服务提供者启动时向eureka注</summary>
      
    
    
    
    <category term="微服务" scheme="https://kallenblue.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务-Spring框架中发起http请求</title>
    <link href="https://kallenblue.github.io/2022/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82/"/>
    <id>https://kallenblue.github.io/2022/10/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82/</id>
    <published>2022-10-13T09:30:16.000Z</published>
    <updated>2023-03-10T11:48:07.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在启动类中注册RestTemplate"><a href="#在启动类中注册RestTemplate" class="headerlink" title="在启动类中注册RestTemplate"></a>在启动类中注册RestTemplate</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>直接使用restTemplate.getForObject()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">        <span class="comment">// 2.查询用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8083/user/&quot;</span>+order.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">        <span class="comment">// 3.封装User信息</span></span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在启动类中注册RestTemplate&quot;&gt;&lt;a href=&quot;#在启动类中注册RestTemplate&quot; class=&quot;headerlink&quot; title=&quot;在启动类中注册RestTemplate&quot;&gt;&lt;/a&gt;在启动类中注册RestTemplate&lt;/h1&gt;&lt;figu</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://kallenblue.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot原理-自定义Starter</title>
    <link href="https://kallenblue.github.io/2022/10/10/SpringBoot%E5%8E%9F%E7%90%86%E7%AF%87/SpringBoot%E5%8E%9F%E7%90%86-%E8%87%AA%E5%AE%9A%E4%B9%89Starter/"/>
    <id>https://kallenblue.github.io/2022/10/10/SpringBoot%E5%8E%9F%E7%90%86%E7%AF%87/SpringBoot%E5%8E%9F%E7%90%86-%E8%87%AA%E5%AE%9A%E4%B9%89Starter/</id>
    <published>2022-10-10T10:25:10.000Z</published>
    <updated>2023-03-10T11:47:55.103Z</updated>
    
    <content type="html"><![CDATA[<p>在SpringBoot中我们需要引入一项新的技术或者功能，往往只是在pom中引入相应的坐标这样简单就完成了，那么现在我们先尝试一下自定义一个starter模块，然后再使用一下</p><h1 id="模块功能"><a href="#模块功能" class="headerlink" title="模块功能"></a>模块功能</h1><p>在web应用中加入一个访问检测器，每当有用户访问网页时，后台打印出其ip地址和访问次数</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ul><li>需要一个web依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建一个新的模块，实现一个业务类，具体功能如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpCount</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ipAddress</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">    <span class="keyword">if</span> (ipCountMap.containsKey(ipAddress))&#123;</span><br><span class="line">      ipCountMap.put(ipAddress,ipCountMap.get(ipAddress)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ipCountMap.put(ipAddress,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;ipAddress:&quot;</span>+ipAddress+<span class="string">&quot;count:&quot;</span>+ipCountMap.get(ipAddress));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HttpServletRequest request;</span><br></pre></td></tr></table></figure><p>HttpServletRequest的bean由使用这个模块的项目提供</p><ul><li>创建一个自动配置类，并初始化刚刚创建的业务类的bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAutoConfiguration</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> IpCount <span class="title function_">ipCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpCount</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在resources下创建META-INF/spring.factories文件，将自动装配信息填入<br>这样就会自动配置IpAutoConfiguration类的bean，同时启动它所依赖的所有bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  cn.ipcount.autoconfig.IpAutoConfiguration</span><br></pre></td></tr></table></figure><p>写好之后用maven上传到本地的库中<br><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/4a55c039-e118-4441-8940-9efe143f7660.png"></p></li><li><p>在需要使用的项目中引入这个依赖即可</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.ipcount<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ipcount_spring_boot_starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>现在就可以将其当做一个普通的第三方包使用了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  IpCount ipCount;</span><br><span class="line">  <span class="meta">@GetMapping</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getAccount</span><span class="params">()</span>&#123;</span><br><span class="line">    ipCount.count();</span><br><span class="line">    System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h1><p>现在我们需要能够自定义属性，在使用时没有配置属性就用默认属性，配置了属性就使用配置的属性</p><ul><li>创建一个配置类<br>这里仅仅设置一个简易的属性note，默认为”检测到用户访问”<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;ipcount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpProperties</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">note</span> <span class="operator">=</span> <span class="string">&quot;检测到用户访问&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> note;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNote</span><span class="params">(String note)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.note = note;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在自动装配类中启用配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(IpProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAutoConfiguration</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> IpCount <span class="title function_">ipCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpCount</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单修改一下业务类中的方法，直接让其打印出note</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpCount</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String,Integer&gt; ipCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> IpProperties ipProperties;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ipAddress</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">    <span class="keyword">if</span> (ipCountMap.containsKey(ipAddress))&#123;</span><br><span class="line">      ipCountMap.put(ipAddress,ipCountMap.get(ipAddress)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ipCountMap.put(ipAddress,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(ipProperties.getNote());</span><br><span class="line">    System.out.println(<span class="string">&quot;ipAddress:&quot;</span>+ipAddress+<span class="string">&quot;count:&quot;</span>+ipCountMap.get(ipAddress));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果没有配置属性，程序会在运行时打印默认的参数，如果在项目中配置了这个属性，那么则会打印配置的值</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ipcount:</span></span><br><span class="line">  <span class="attr">note:</span> <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">ipAddress:[0:0:0:0:0:0:0:1]count:1</span><br><span class="line">get...</span><br></pre></td></tr></table></figure><h1 id="加一个拦截器"><a href="#加一个拦截器" class="headerlink" title="加一个拦截器"></a>加一个拦截器</h1><p>这个模块目前只能在一个account-get请求里面使用，我们希望在所有资源请求都使用这个功能，于是想到了使用拦截器，当然也可以使用AOP，但是这是一个web应用，优先考虑拦截器。关于拦截器的知识也在之前的文章中已经解释过</p><ul><li>自定义拦截器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> IpCount ipCount;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ipCount.count();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置核心配置类，加载拦截器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> IpInterceptor <span class="title function_">interceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpInterceptor</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    registry.addInterceptor(interceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在IpAutoConfiguration中引入SpringMvcConfig</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(IpProperties.class)</span></span><br><span class="line"><span class="meta">@Import(SpringMvcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpAutoConfiguration</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> IpCount <span class="title function_">ipCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IpCount</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开启配置提示功能"><a href="#开启配置提示功能" class="headerlink" title="开启配置提示功能"></a>开启配置提示功能</h1><p>目前设计的starter在配置上面没有提示功能，如果拿给别人用的话别人也搞不明白你这些配置到底是干嘛用的，所以一般会加上提示功能</p><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入依赖后重新打包项目，项目中会出现target/classes/META-INF/spring-configuration-metadata.json这个文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;groups&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ipcount&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.ipcount.properties.IpProperties&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.ipcount.properties.IpProperties&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ipcount.note&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.String&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.ipcount.properties.IpProperties&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;收到用户访问&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hints&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>把这个文件移动到项目中的resources/META-INF文件夹中，然后把上面引入的依赖去掉，否则会出现两种提示，实际上自己来编写这个spring-configuration-metadata.json文件也是可以的，只是依赖生成可以省去书写的过程</p><ul><li>hints提示可以选择的值</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;hints&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ipcount.note&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;提示1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;提示的一种模式.&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;提示2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;提示的另一种模式.&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>最后效果如下<br><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-ceb77253-93f0-4559-a375-815102654932/fce7c0be-a5ba-4c23-af66-1ead91863512.png"><br>ok，这样一来我们就成功定义了一个相对完整的starter，进一步了解了SpringBoot的自动装配机制</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在SpringBoot中我们需要引入一项新的技术或者功能，往往只是在pom中引入相应的坐标这样简单就完成了，那么现在我们先尝试一下自定义一个starter模块，然后再使用一下&lt;/p&gt;
&lt;h1 id=&quot;模块功能&quot;&gt;&lt;a href=&quot;#模块功能&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://kallenblue.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot原理-自动装配</title>
    <link href="https://kallenblue.github.io/2022/10/09/SpringBoot%E5%8E%9F%E7%90%86%E7%AF%87/SpringBoot%E5%8E%9F%E7%90%86-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>https://kallenblue.github.io/2022/10/09/SpringBoot%E5%8E%9F%E7%90%86%E7%AF%87/SpringBoot%E5%8E%9F%E7%90%86-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</id>
    <published>2022-10-09T11:53:33.000Z</published>
    <updated>2023-03-10T11:47:54.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bean的加载控制"><a href="#bean的加载控制" class="headerlink" title="bean的加载控制"></a>bean的加载控制</h1><p>springboot最常使用的控制bean加载的注解为@Condition<strong>，即在</strong>情况下加载bean<br>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.kallen.springbootlearning.bean.Mouse&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;com.kallen.springbootlearning.bean.Dog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bean的依赖属性配置"><a href="#bean的依赖属性配置" class="headerlink" title="bean的依赖属性配置"></a>bean的依赖属性配置</h1><p>用一个简单的案例模拟springboot的属性配置</p><ul><li>将业务功能bean运行需要的资源抽取成独立的属性类（***Properties），设置读取配置文件信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;cartoon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartoonProperties</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Cat cat;</span><br><span class="line">  <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置的属性如下<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cartoon:</span></span><br><span class="line">  <span class="attr">cat:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;coco&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">mouse:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;tutu&quot;</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li>业务类如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CartoonProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TomAndJerry</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Cat cat;</span><br><span class="line">  <span class="keyword">private</span> Mouse mouse;</span><br><span class="line">  <span class="keyword">private</span> CartoonProperties cartoonProperties;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TomAndJerry</span><span class="params">(CartoonProperties cartoonProperties)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.cartoonProperties = cartoonProperties;</span><br><span class="line">    cat = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    cat.setName(cartoonProperties.getCat()!=<span class="literal">null</span> &amp;&amp; StringUtils.hasText(cartoonProperties.getCat().getName())?cartoonProperties.getCat().getName():<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    cat.setAge(cartoonProperties.getCat()!=<span class="literal">null</span>&amp;&amp;cartoonProperties.getCat().getAge()!=<span class="literal">null</span>?cartoonProperties.getCat().getAge():<span class="number">3</span>);</span><br><span class="line">    mouse = <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">    mouse.setName(cartoonProperties.getMouse()!=<span class="literal">null</span> &amp;&amp; StringUtils.hasText(cartoonProperties.getMouse().getName())?cartoonProperties.getMouse().getName():<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">    mouse.setAge(cartoonProperties.getMouse()!=<span class="literal">null</span>&amp;&amp;cartoonProperties.getMouse().getAge()!=<span class="literal">null</span>?cartoonProperties.getMouse().getAge():<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(cat.getAge()+<span class="string">&quot;岁的&quot;</span>+cat.getName()+<span class="string">&quot;在抓&quot;</span>+ mouse.getAge()+<span class="string">&quot;岁的&quot;</span>+ mouse.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，@EnableConfigurationProperties(CartoonProperties.class)和配置类联系在了一起，只有在业务类启用时才会去加载配置类</p><ul><li>实体类如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果在配置文件中配置了Cat和Mouse的属性，那么配置的属性就会覆盖默认值，没有配置也不影响，程序会按照默认配置运行。并且只有使用了业务类，程序才会去加载与业务类相关的一系列的bean</p><h1 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h1><h2 id="自动装配思想"><a href="#自动装配思想" class="headerlink" title="自动装配思想"></a>自动装配思想</h2><ul><li>1.收集整理常用的技术列表-&gt;(技术集A)</li><li>2.收集常用技术列表中的使用参数-&gt;(设置集B)</li><li>3.初始化基础环境，加载自定义的bean并导入其他坐标</li><li>4.将技术集A中的所有技术都定义出来，在Spring/SpringBoot启动时默认全部加载</li><li>5.将技术集A设置成按条件加载，由开发者决定是否使用该技术</li><li>6.将设置集B作为默认配置加载(<strong>约定大于配置</strong>),减少配置的工作量</li><li>7.开放设置集B的配置覆盖接口，由开发者根据自身需要决定是否覆盖默认配置</li></ul><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><p>很好奇，启动springboot项目只需要启动一个Application类下带有@SpringBootApplication注解的main方法即可，于是我们重点来看这个@SpringBootApplication注解<br>逐一点开可以看到它的层级如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">  <span class="meta">@SpringBootConfiguration</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">      <span class="meta">@Component</span></span><br><span class="line">    <span class="comment">//运行期加速启动</span></span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line">  <span class="meta">@EnableAutoConfiguration</span></span><br><span class="line">    <span class="meta">@AutoConfigurationPackage</span></span><br><span class="line">      <span class="comment">//设置当前配置所在包作为扫描包，后续要针对当前的包进行包扫描</span></span><br><span class="line">      <span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line">    <span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line">  <span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br></pre></td></tr></table></figure><p>下面进行一一解释，但不会完全解释，只是简述一下各部分的功能，有些重点的地方会展开解释</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>顶层配置</p><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>标记为配置类，封装了@Configuration，并做了一些加强</p><h5 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h5><h6 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h6><h5 id="Indexed"><a href="#Indexed" class="headerlink" title="@Indexed"></a>@Indexed</h5><p>运行期加速启动</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>自动配置的主要实现方式</p><h5 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h5><p>设置当前配置所在包作为扫描包，后续要针对当前的包进行包扫描</p><h6 id="Import-AutoConfigurationPackages-Registrar-class"><a href="#Import-AutoConfigurationPackages-Registrar-class" class="headerlink" title="@Import(AutoConfigurationPackages.Registrar.class)"></a>@Import(AutoConfigurationPackages.Registrar.class)</h6><p>查看Registrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Registrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata).getPackageNames().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register(registry, <span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata).getPackageNames()</span><br></pre></td></tr></table></figure><p>则是获取启动器所在的包的报名<br>查看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(BeanDefinitionRegistry registry, String... packageNames)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;</span><br><span class="line"><span class="type">BasePackagesBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> (BasePackagesBeanDefinition) registry.getBeanDefinition(BEAN);</span><br><span class="line">beanDefinition.addBasePackages(packageNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">registry.registerBeanDefinition(BEAN, <span class="keyword">new</span> <span class="title class_">BasePackagesBeanDefinition</span>(packageNames));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry.registerBeanDefinition(BEAN, <span class="keyword">new</span> <span class="title class_">BasePackagesBeanDefinition</span>(packageNames));</span><br></pre></td></tr></table></figure><p>则是注册这个启动器的bean，为后续扫路径下的包做准备</p><h5 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h5><p>这个选择器是用来选择项目所需要的资源，加载初始集<br>查看AutoConfigurationImportSelector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class="line">ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered</span><br></pre></td></tr></table></figure><p>这个类继承了很多接口，分为三类：以Aware结尾的接口可以获取各个类型的bean及其信息(BeanClassLoaderAware,ResourceLoaderAware, BeanFactoryAware, EnvironmentAware)，Ordered用来规定bean的加载顺序，DeferredImportSelector为延时加载选择器<br>AutoConfigurationImportSelector类通过DeferredImportSelector接口实现了process方法，加载资源主要就源自这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> &#123;</span><br><span class="line">Assert.state(deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">() -&gt; String.format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">deferredImportSelector.getClass().getName()));</span><br><span class="line"><span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"><span class="built_in">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line"><span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line"><span class="built_in">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">    .getAutoConfigurationEntry(annotationMetadata);</span><br></pre></td></tr></table></figure><p>中的getAutoConfigurationEntry方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//排除不需要的资源</span></span><br><span class="line"><span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure><p>就是获得所有的技术集，继续查看getCandidateConfigurations方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">List&lt;String&gt; configurations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line"><span class="string">&quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看其中的SpringFactoriesLoader.loadFactoryNames()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoaderToUse</span> <span class="operator">=</span> classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line"><span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的loadSpringFactories()方法就是最终获取技术集的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line"><span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">String[] factoryImplementationNames =</span><br><span class="line">StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line"><span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">.add(factoryImplementationName.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的classLoader.getResources(FACTORIES_RESOURCE_LOCATION);<br>FACTORIES_RESOURCE_LOCATION的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure><p>而这个文件中就保存了所有的技术集<br>而至于技术集是否应用则是通过是否有引入来决定了，在注解中使用@Conditional**来实现</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>这一部分主要就是用来过滤一些不需要的东西</p><h2 id="自定义自动配置"><a href="#自定义自动配置" class="headerlink" title="自定义自动配置"></a>自定义自动配置</h2><p>在resources包下新建META-INF/spring.factories文件，格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  com.kallen.springbootlearning.bean.TomAndJerry</span><br></pre></td></tr></table></figure><p>将需要配置的包写在下面即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bean的加载控制&quot;&gt;&lt;a href=&quot;#bean的加载控制&quot; class=&quot;headerlink&quot; title=&quot;bean的加载控制&quot;&gt;&lt;/a&gt;bean的加载控制&lt;/h1&gt;&lt;p&gt;springboot最常使用的控制bean加载的注解为@Condition&lt;stro</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://kallenblue.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot原理篇-Bean加载方式</title>
    <link href="https://kallenblue.github.io/2022/10/09/SpringBoot%E5%8E%9F%E7%90%86%E7%AF%87/SpringBoot%E5%8E%9F%E7%90%86%E7%AF%87-Bean%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/"/>
    <id>https://kallenblue.github.io/2022/10/09/SpringBoot%E5%8E%9F%E7%90%86%E7%AF%87/SpringBoot%E5%8E%9F%E7%90%86%E7%AF%87-Bean%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/</id>
    <published>2022-10-08T16:38:43.000Z</published>
    <updated>2023-03-10T11:47:54.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-XML方式声明bean"><a href="#1-XML方式声明bean" class="headerlink" title="1.XML方式声明bean"></a>1.XML方式声明bean</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--声明自定义bean--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Learning1.service.impl.Service&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--声明第三方开发bean--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-XML-注解方式声明bean"><a href="#2-XML-注解方式声明bean" class="headerlink" title="2.XML+注解方式声明bean"></a>2.XML+注解方式声明bean</h1><ul><li>此种方式需要在xml配置文件中声明命名空间<br>开启命名空间后，指定包扫描位置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.Learning2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>然后使用@Component注解以及其衍生注解@Controller，@Service，@Repository定义bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果要定义第三方bean，需要使用@Bean注解定义在方法上面，并将所在类定义为配置类或Bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbConfig</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> DruidDataSource <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>@Configuration注解包含了@Component注解</li></ul><h1 id="3-纯注解加载Bean"><a href="#3-纯注解加载Bean" class="headerlink" title="3.纯注解加载Bean"></a>3.纯注解加载Bean</h1><p>将xml配置文件改为一个配置类，用配置类取代xml配置的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.Learning2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于FactoryBean接口的类"><a href="#关于FactoryBean接口的类" class="headerlink" title="关于FactoryBean接口的类"></a>关于FactoryBean接口的类</h2><p>实现FactoryBean接口的类也是用来创建bean的，它存在的意义就在于能够在bean创建之前进行一系列的前置工作，比如判断创建条件，设置bean的信息等<br>对实现了FactoryBean接口的类加上@Bean注解，创建出来的bean不是那个类而是工厂造出来的对象的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;TestDao&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> TestDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestDaoImpl</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    <span class="keyword">return</span> TestDao.class;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于-Configuration注解中的proxyBeanMethods属性"><a href="#关于-Configuration注解中的proxyBeanMethods属性" class="headerlink" title="关于@Configuration注解中的proxyBeanMethods属性"></a>关于@Configuration注解中的proxyBeanMethods属性</h2><p>proxyBeanMethods=true可以保证调用有@Configuration注解的类的方法得到的对象是从spring容器中获取的而不是重新创建的。proxyBeanMethods的默认值是true</p><h1 id="4-使用-Import注解导入"><a href="#4-使用-Import注解导入" class="headerlink" title="4.使用@Import注解导入"></a>4.使用@Import注解导入</h1><p>将需要其对象注册为Bean的类作为参数填入@Import注解中即可<br>这种形式可以有效的降低源代码与spring技术的耦合度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-使用上下文对象在容器初始化完毕后注入bean"><a href="#5-使用上下文对象在容器初始化完毕后注入bean" class="headerlink" title="5.使用上下文对象在容器初始化完毕后注入bean"></a>5.使用上下文对象在容器初始化完毕后注入bean</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    applicationContext.register(UserService.class);</span><br><span class="line">    applicationContext.registerBean(<span class="string">&quot;testDao&quot;</span>,TestDao.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-通过ImportSelector接口加载bean"><a href="#6-通过ImportSelector接口加载bean" class="headerlink" title="6.通过ImportSelector接口加载bean"></a>6.通过ImportSelector接口加载bean</h1><p>在配置类中导入实现了ImportSelector接口的类，实现对导入源的编程式处理<br>谁引用了这个类，这个类就可以获取这个类的一系列信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">    importingClassMetadata.hasAnnotation(<span class="string">&quot;org.springframework.context.annotation.Configuration&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.Learning2.Dog&quot;</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-通过ImportBeanDefinitionRegistrar接口创建bean"><a href="#7-通过ImportBeanDefinitionRegistrar接口创建bean" class="headerlink" title="7.通过ImportBeanDefinitionRegistrar接口创建bean"></a>7.通过ImportBeanDefinitionRegistrar接口创建bean</h1><p>这种方法深入到bean的定义过程，使用方法和上一种类似<br>导入实现了ImportBeanDefinitionRegistrar接口的类，通过beanDefinition的注册器注册实名bean，实现对容器中bean的裁定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,</span></span><br><span class="line"><span class="params">      BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                                    .rootBeanDefinition(Dog.class)</span><br><span class="line">                                    .getBeanDefinition();</span><br><span class="line">    registry.registerBeanDefinition(<span class="string">&quot;dodo&quot;</span>,beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-BeanDefinitionRegistryPostProcessor决定bean的创建"><a href="#8-BeanDefinitionRegistryPostProcessor决定bean的创建" class="headerlink" title="8.BeanDefinitionRegistryPostProcessor决定bean的创建"></a>8.BeanDefinitionRegistryPostProcessor决定bean的创建</h1><p>这个接口是bean创建的最终决定接口，实现了这个接口的类可以处理之前过程中已经创建的bean，也可以新增bean，是一个最终裁定的接口<br>使用方式和上一个接口的方式类似<br>导入实现了BeanDefinitionRegistryPostProcessor接口的类，通过BeanDefinition的注册器注册实名bean，实现对容器中bean的最终裁定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;MyPostProcessor.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">        .rootBeanDefinition(Dog.class)</span><br><span class="line">        .getBeanDefinition();</span><br><span class="line">    beanDefinitionRegistry.registerBeanDefinition(<span class="string">&quot;dodo&quot;</span>,beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">      ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面8种方式spring还有一些其他的加载bean的方式，这里就不再叙述了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-XML方式声明bean&quot;&gt;&lt;a href=&quot;#1-XML方式声明bean&quot; class=&quot;headerlink&quot; title=&quot;1.XML方式声明bean&quot;&gt;&lt;/a&gt;1.XML方式声明bean&lt;/h1&gt;&lt;figure class=&quot;highlight xml&quot;</summary>
      
    
    
    
    <category term="SpringBoot" scheme="https://kallenblue.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
</feed>
